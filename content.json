{"pages":[{"title":"About","text":"本网站依托于GitHub pages，采用Hexo，主题为Icarus，图床采用SM.MS。Repository","link":"/about/index.html"}],"posts":[{"title":"2021 新年快乐","text":"新的一年再次从gakki的问候开始 她还是那么喜欢吃肉","link":"/2021/01/01/happy-new-year-2021/"},{"title":"scipy.optimize.minimize如何传入多个向量(矩阵)","text":"记一次困扰了一周的问题 向量一般情况下，对于一个多维函数的优化，往往是把$x_0, x_1, … ,x_n$放进一个$1 \\times n$的数组中，然后把这个数组作为minimize的参数x0。但现在碰到了一个这样的问题，优化函数为：$$min||x-z||_2$$ 约束为$Ax-b\\leq0$并且$z\\geq0$，其中A是一个$m \\times n$的矩阵，b是$m \\times 1$的矩阵。也就是说，x和z均为一个n维的向量。 起初我的思路是将x和z强行放在一个数组x0里，x作为x0[0]，z作为x0[1]。但这样在添加约束的时候会发生错误，大概是因为在约束函数里x0[0]被当作了一个1x1的元素，无法点乘也无法与b进行相减。 这个思路没有错，但是把x和z压成一个向量的话，需要用到numpy里的hstack函数，这样等于是把x和z拼接成一个1x2n的向量而非一个2xn的矩阵。这样的话在优化函数中需要重新将这个1x2n的向量拆成两个1xn的向量： 123456789101112x = np.zeros(A.shape[1])z = np.zeros(A.shape[1])x0 = np.hstack([x, z])def to_x_z(x0): x = x0[:A.shape[1]] z = x0[A.shape[1]:] return x, zdef f(x0): x, z = to_x_z(x0) return np.linalg.norm([x-z], ord=2) 在约束中也是一样，需要对x0进行拆分。再返回结果的时候也是同样。 1234cons = [{'type': 'ineq', 'fun': lambda x: b-np.dot(A, to_x_z(x)[0])}, {'type': 'ineq', 'fun': lambda x: to_x_z(x)[1] - 1e-10}]res = scipy.optimize.minimize(f, x0, method='SLSQP', constraints=cons)res.x = to_x_z(res.x)return res.x 矩阵若传入的是矩阵而非向量，思路也是一样，但是需要利用numpy里的flatten来先对每个矩阵进行压缩： 1np.hstack([w.flatten(), z.flatten()]) 在拆分的时候，需要reshape一下让其恢复成矩阵： 1234def to_x_z(x0): x = x0[:A.shape[1]].reshape(m, n) z = x0[A.shape[1]:].reshape(m, n) return x, z 参考 How Do I put 2 matrix into scipy.optimize.minimize?","link":"/2020/11/19/scipy-minimize-with-vectors/"},{"title":"Maximum Mean Discrepancy 最大化均值差异","text":"天杀的mmd记录。 核心思想mmd最早的提出便是为了衡量任意两个随机变量分布之间的差异，它是一种度量标准，可视作一种距离。 矩，moment，通常用来描述一个随机变量的分布。简单的例如一阶中心矩，期望；二阶中心矩，方差。但单单的期望和方差不足以描述一个高维的随机变量，这时便需要一个高维的矩来描述一个高维分布。 若两个分布任意阶的矩都一样的话，那么这两个分布便是一致的；若两个分布不一样，那么便用差值最大的矩来衡量这两个分布的差异。这便是mmd的核心思想。 定义在 [1] 中，一个普适的mmd定义为$$MMD[\\mathcal{F},p,q]:=\\mathop{sup}\\limits_{f\\in\\mathcal{F}}(E_p{[f(x)]}-E_q{[f(y)]})$$此式的含义是寻找一个映射函数$f$，这个映射函数能够将变量映射到高维空间，之后求两个分布的随机变量在映射后的期望的差，这个差值便是mean discrepancy，然后寻找这个mean discrepancy的上确界。这个最大值便是mmd。 现在有两个样本$X$和$Y$，其中$X\\sim p,Y\\sim q$，那么有$$MMD[\\mathcal{F},p,q]:=\\mathop{sup}\\limits_{f\\in\\mathcal{F}}\\left(\\frac{1}{m}\\sum_{i=1}^m{f(x_i)}-\\frac{1}{n}\\sum_{j=1}^n{f(y_j)}\\right)$$ RKHS下的定义再生希尔伯特空间，reproducing kernel Hilbert space (RKHS)，是一种有再生性质的希尔伯特空间。希尔伯特空间是一种内积空间，而再生希尔伯特空间拥有${\\langle k(x,\\cdot),k(y,\\cdot)\\rangle}_\\mathcal{H}=k(x,y)$的性质。在迁移学习里的mmd一般用RKHS下定义的mmd，主要目的是为了后续计算中将内积计算转变为核函数。 在RKHS中$E_p{[f(x)]}$的计算可以转化为$$E_p{[f(x)]}=\\int_\\mathcal{X}p(dx)f(x)=\\int_\\mathcal{X}p(dx)\\langle k(x,\\cdot),f\\rangle_\\mathcal{H}=\\langle \\int_\\mathcal{X}p(dx)k(x,\\cdot),f\\rangle_\\mathcal{H}=\\langle \\mu_p,f\\rangle_\\mathcal{H}$$ 上述公式第一个等号就是普通的期望展开计算；第二个等号用了所谓的再生性，将映射函数变为了一个核函数和基底向量的内积；第三个等号是内积的性质；最后一个等号将内积括号中左侧部分定义成了$\\mu_p$，这个东西叫 kernel meaning embeddings，具体的定义为$$\\mu_p=\\int_\\mathcal{X}p(dx)k(x,\\cdot)\\mu_p=\\int_\\mathcal{X}p(dx)k(x,\\cdot)$$ [1]中给出了RKHS下的mmd计算方法： $$ MMD^2[\\mathcal{F},p,q]=\\left\\|\\mu_p-\\mu_q\\right\\|_\\mathcal{H}^2 $$ 并给出了简短的证明： $$ \\begin{align} MMD^2[\\mathcal{F},p,q] &= \\left[\\mathop{sup}\\limits_{\\left\\|f\\right\\|_\\mathcal{H}\\leq1}(E_p{[f(x)]}-E_q{[f(y)]})\\right]^2 \\\\ & =\\left[\\mathop{sup}\\limits_{\\left\\|f\\right\\|_\\mathcal{H}\\leq1}\\langle \\mu_p-\\mu_q,f\\rangle_\\mathcal{H}\\right]^2 \\\\ & =\\left\\|\\mu_p-\\mu_q\\right\\|_\\mathcal{H}^2 \\end{align} $$ 其中第二个等号到最后一个等号利用的性质为$\\langle a,b\\rangle \\leq \\left\\|a\\right\\| \\left\\|b\\right\\|$。 所以，RKHS下的mmd可以写为 $$ MMD^2[\\mathcal{F},p,q]=\\left\\| \\frac{1}{m}\\sum_{i=1}^m{f(x_i)}-\\frac{1}{n}\\sum_{j=1}^n{f(y_j)} \\right\\|_\\mathcal{H}^2 $$ 经过展开，可得 $$ MMD^2[\\mathcal{F},p,q]=\\left\\| \\frac{1}{m^2}\\sum_{i=1,j=1}^m{k(x_i,x_j)}-\\frac{2}{mn}\\sum_{i=1,j=1}^{m,n}{k(x_i,y_j)}+\\frac{1}{n^2}\\sum_{i=1,j=1}^n{k(y_i,y_j)} \\right\\|_\\mathcal{H}^2 $$ Reference A Kernel Two-Sample Test A Hilbert Space Embedding for Distributions 统计知识（一）MMD Maximum Mean Discrepancy 最大均值差异 迁移学习简明手册","link":"/2021/04/30/mmd/"},{"title":"JS原型与继承","text":"ECMAScript 2015 中引入的 JavaScript 类实质上是 JavaScript 现有的基于原型的继承的语法糖。类语法不会为JavaScript引入新的面向对象的继承模型。 MDN Web doc 在设计之初，JS本身只是单纯的作为一个用于网页设计的脚本语言，所以其并没有设计得很复杂。而对于继承，JS采用了原型的形式。 prototype与__proto__JS中万物皆对象，函数也是一种对象。 每个函数对象都有一个prototype属性，而普通的对象没有。下面是一个Foo函数对象： 123function Foo(attr) { this.attr = attr;} 对于每一个函数对象，都拥有一个prototype原型。在默认情况下，所有的原型都会自动获得一个constructor属性，这个属性指向 prototype 属性所在的函数对象。在上面这个例子中，Foo的prototype中的constructor属性指向的就是Foo这个函数对象。 下面我们将Foo函数当作构造函数来实例化两个对象： 12var f1 = new Foo('A');var f2 = new Foo('B'); 在每一个实例中也会有一个constructor属性，其指向实例的构造函数。除此之外，每个对象(是任何对象，不止函数对象）还都会有一个__proto__属性，这个属性用来指向它们的原型对象prototype。 用一张图来总结一下： 对此，我们可以用一段代码来验证一下： 1234Foo.prototype.constructor === Foo //truef1.constructor === Foo //truef1.__proto__ === Foo.prototype //truef2.__proto__ === f1.__proto__ //true 原型链先举个例子，我们使用上面实例化的f1并在控制台打印valueOf的结果： 1console.log(f1.valueOf()); 此时我们在浏览器控制台查看一下f1：我们会发现，在我们的Foo构造器中，并没有声明valueOf这个函数。通过控制台查看f1中的__proto__属性，也就是Foo的原型，发现原型中也没有valueOf这个函数。但是我们发现在Foo的原型中依然有__proto__这个属性，前文说过，原型也是一个对象，它自然也有__proto__属性。现在我们再查看prototype的__proto__属性：我们发现，Foo的prototype的prototype是object的prototype，而valueOf正是object的prototype里的方法。所以，valueOf函数的查找过程大致可以描述为： 当前obj为f1，在实例f1中查找，若找直接返回。 在f1中没有找到，根据f1.__proto__查找f1的原型，若找到则返回。 在f1的原型中没有找到，将Foo.prototype作为obj重复1。 若一直没有找到，会发现Object.prototype.__proto__为null，停止查找。 123456f1.__proto__ === Foo.prototypef1.__proto__.__proto__ === Object.prototypeFoo.prototype.__proto__ === Object.prototypeObject.prototype.__proto__ === nullf1.__proto__.__proto__.__proto__ === nullFoo.prototype.__proto__.__proto__ === null 上面这个链式关系就可以称作原型链。对于查找f1的方法，原型链大致如下：f1 –&gt; Foo.prototype –&gt; Object.prototype –&gt; null 继承现在来说大头，JS中的继承。JS的继承有很多很多花样。 原型链继承核心很简单，将子类的原型设置为父类的实例。 12345678910111213141516function Parent(attr) { this.attr = attr; this.foo = 1;}function Child(attr) { this.attr = attr; this.bar = 2;}Child.prototype = new Parent();var child = new Child('A');console.log(child.attr); //A, 子类覆写父类属性console.log(child.foo); //1, 父类属性console.log(child.bar); //2, 子类属性 若要继承方法，只需正常在prototype里声明就可以了： 123456789101112131415161718function Parent(attr) { this.attr = attr; this.foo = 1;}Parent.prototype.doSomething = function() { alert('DO SOMETHING!');}function Child(attr) { this.attr = attr; this.bar = 2;}Child.prototype = new Parent();var child = new Child('A');child.doSomething(); 这里说一点题外话，就是函数为什么要写在原型里而非构造器里。其实就结果来讲，写在构造器里和函数里的效果是一样的，也就是说上面的代码效果等同于下面： 1234567891011121314151617function Parent(attr) { this.attr = attr; this.foo = 1; this.doSomething = function() { alert('DO SOMETHING!'); }}function Child(attr) { this.attr = attr; this.bar = 2;}Child.prototype = new Parent();var child = new Child('A');child.doSomething(); 但两者牵扯到内存的问题。若是函数写在了构造器里，假设我们现在实例了两个parent, attr分别为p1和p2，他们内部是这样的(下图省去了一些无关的属性或方法）：但如果是写在了prototype里：可见prototype更像是一个公共容器，如果要实例化很多对象并且函数不会对私有属性进行访问或更改的话，函数声明建议写在prototype里。但若此方法需要访问私有变量的话，写在prototype里就显然没有用了。 回到正题，这种继承方法很好理解，但他有一些问题：若父类中有引用类型成员变量，子类继承的是引用本身，若现在有多个实例化的子类，一个子类对引用类型的成员变量进行更改的话，另一个中相应的变量也会被更改。 123456789101112function Parent() { this.arr = [1, 2];}function Child() {}Child.prototype = new Parent();var c1 = new Child();var c2 = new Child();c1.arr.push(3);console.log(c2.arr); //[1, 2, 3] 注意！我们在开头讲到，原型的constructor应当是指向构造函数的。但在继承之后，子类的原型的constructor是指向父类的，因为我们调用了Child.prototype = new Parent();。所以我们最好手动设置一下Child.prototype.constructor = Child。 构造器继承这种继承方法就跟原型没多大关系了，但它能解决上面的问题，同时，父类还可以向子类传递参数。构造器继承的方式如下： 12345678910111213function Parent() { this.arr = [1, 2];}function Child() { Parent.call(this);}var c1 = new Child();var c2 = new Child();c1.arr.push(3);console.log(c1.arr); //[1, 2, 3]console.log(c2.arr); //[1, 2] 此种方法通过在子类中调用父类的构造函数来实现继承，因为每new一个子类都会执行一遍父类的构造函数，多个子类之间的引用类型成员变量并不会共享。 但是这也有一个问题，就是函数也是引用类型变量，若采用此种继承方式，父类的函数会分别复制一份至各个子类中，就像上文讲到的将方法写在构造器中一样，造成了不少浪费。 组合继承从上面两部分可以看到，原型链继承和构造器继承是互相对立的，你的优点是我的缺点，我的缺点是你的优点。那有没有什么方法可以兼得鱼和熊掌？我们的组合继承就诞生了。 在此，我们将两者混合在一起： 1234567891011121314151617181920function Parent() { this.arr = [1, 2];}Parent.prototype.doSomething = function() { alert('DO SOMETHING!');}function Child() { Parent.call(this);}Child.prototype = new Parent();var c1 = new Child();var c2 = new Child();c1.arr.push(3);console.log(c1.arr); //[1, 2, 3]console.log(c2.arr); //[1, 2]console.log(c1.doSomething === c2.doSomething); //true 组合继承也有缺点，因为我们调用了两次父类的构造函数，一定程度上造成了性能的浪费。 原型式继承12345function object(obj) { function F() {} F.prototype = obj; return new F();} 上面是原型式继承的代码，在object函数中，我们先构造了一个空的构造器F，然后将F的prototype指向obj，再实例化并返回。它和第一个讲的原型链继承长得非常像，只不过就是外面多了一层壳。所以它和原型链继承有一样的缺点，例如没法传递参数，会有引用问题等等。 那么它和原型链继承的区别在于obj这个参数，obj这个变量不一定非要是构造函数，也可以是任何的对象。这样整个过程下来我们就相当于深复制了一个obj对象。ES5中的Object.create()函数就是采用了此种方式。 寄生式继承名字很nb，但实质上就是对原型式继承做了一些增进，原型式继承理解了，这个就没什么困难的了。 1234567function clone(obj) { var f = object(obj) f.doSomething = function() { alert('DO SOMETHING!'); } return f;} 其改进之处就是在浅复制obj的基础上为对象添加了函数，但它同构造器继承一样仍有函数无法复用的缺点。 寄生组合式继承终极版来了。由于组合继承需要调用两次构造函数，一次在Child.prototype = new Parent()处，一次在Parent.call(this)处，所以推出了寄生组合式继承来弥补这个缺陷。 下面的inherit函数实现了简单的寄生组合式继承。 12345function inherit(child,parent) { var prototype = object(parent.prototype); //浅复制一份父类的原型 prototype.constructor = child; //调整constructor的指向 child.prototype = prototype; //将子类的prototype指向我们的副本} 12345678910111213function Parent() { this.arr = [1, 2];}Parent.prototype.doSomething = function() { alert('DO SOMETHING!');}function Child() { Parent.call(this);}inherit(Child, Parent); 在整个继承代码中，父类的构造函数只在call部分调用了一次，从而避免了组合继承中的重复调用。 在我第一个看到这个寄生组合式继承的代码的时候，一直有一个疑惑，这个继承形式就是将Child.prototype = new Parent()改为了inherit(Child, Parent)。那我可否将组合继承中的Child.prototype = new Parent()改为Child.prototype = Parent.prototype？这样不也就避免了重复调用父类构造器了吗？但其实这样会引入一个问题，就是此时Child.prototype和Parent.prototype指向了同一个原型对象。当我在Child.prototype中添加一个函数时，Parent.prototype也增加了。这也是为什么在寄生组合式继承中一直强调创建父类原型对象的深复制的副本。 Object与Function在此谈点题外的东西。在研究原型的时候，发现了一个有趣的东西。 众所周知，Object和Function是JS的两个内置对象。在原型链部分也有提到，一切对象的原型链最终都会回到Object.prototype –&gt; null。也就是说，一切对象都包含Object原型对象中的属性方法。 同时，一切函数对象的原型链又源自Function.prototype。例如String，Array或者Function本身，他们都是函数对象，所以他们的__proto__属性都指向Function.prototype。最有意思的是，Object本身也显然是个函数对象，所以Object的__proto__自然也指向Function.prototype。 1234String.__proto__ === Function.prototypeArray.__proto__ === Function.prototypeFunction.__proto__ === Function.prototypeObject.__proto__ === Function.prototype 那么，也就是说Object的__proto__指向Function的prototype，Funtion的prototype的__proto__又指向Object的prototype：非常的amazing啊。总结来说，一切普通对象都继承自Object.prototype，而对于函数对象，在中间还继承了Function.prototype，Function.prototype同样也是个普通对象，也继承自Object.prototype。 其实‘继承’这个讲法不准确，因为JS并没有直接的继承，所有的继承都基于原型链，更准确的说法应该是一切对象的原型链在最后都会回归到–&gt;Object.prototype–&gt;null，而函数对象在此之前会先回到Function的prototype：–&gt;Function.protype–&gt;Object.prototype–&gt;null。 参考链接 JavaScript 中的继承Object.prototype.__proto__继承与原型链","link":"/2020/04/10/js-prototype-and-inheritance/"},{"title":"Docker部署Flask","text":"最近闲得想把flask项目部署到服务器上，参考了官方文档后，最初选择的是Apache的httpd+mod_wsgi。但apache的配置实在是过于繁琐，各种错误频频发生。尽管通过参考一些网上的资料排除了许多故障，但最后的404问题实在不知道怎么解决。之后转战uWSGI+nginx，但最后的nginx error实在是让我束手无策…… httpd和nginx的错误日志里也没有显示什么，项目在开发环境中也没有问题……所以干脆放弃了，改用了Docker。 安装Docker这点就不用详细说明什么了，正常安装就可以了。 1$ yum install docker Gunicorn + Gevent由于flask是一个基于wsgi标准的python应用，app.run()这类方法只可以在开发环境下使用，也就是说，flask项目不可以独立运行，需要其他中间件来提供web服务器功能。此处使用的是Gunicorn。为了弥补并发量，采用Gevent。Gevent能够提供对于协程的支持。 Gunicorn和Gevent需要使用pip进行安装 1$ pip install gunicorn gevent 可见，两者是python的第三方库，所以此处安装只是为了后面测试用。Docker build镜像的时候还需要另作安装。 相关配置在项目文件夹下新建gunicorn.conf.py配置文件 123workers = 5 #定义处理的进程数量，可根据需求自行定义worker_class = &quot;gevent&quot;bind = &quot;0.0.0.0:5000&quot; #端口号可自行定义 通过下面的命令来进行测试 1gunicorn your_startup_file:app -c gunicorn.conf.py 其中your_startup_file为flask项目的运行文件，例如，项目中的python启动文件为app.py，此处就改为app。 在项目文件夹下创建一个文本文档，用来存储项目需要的依赖包，以便Docker在build的时候知道需要安装哪些库。此处我命名为packages.txt。 1$ vi packages.txt 打开后，根据个人需求写下项目需要的依赖包。 123456gunicorngeventflaskflask_corstensorflow... 之后，创建一个Dockerfile文件，指导Docker进行镜像的构建。 1$ vi Dockerfile 以下是Dockerfile的内容： 123456789FROM python:3.6WORKDIR the/path/to/your/applicationCOPY requirements.txt ./RUN pip install -r packages.txtCOPY . .CMD [&quot;gunicorn&quot;, &quot;your_startup_file:app&quot;, &quot;-c&quot;, &quot;./gunicorn.conf.py&quot;] 其中第二行为访问项目文件夹的绝对路径。最后一行的your_startup_file为flask项目的运行文件。第四行是告诉docker执行pip install -r packages.txt来进行依赖包的安装，根据需求可在后面添加安装源。例如添加清华源：pip install -r packages.txt -i https://pypi.tuna.tsinghua.edu.cn/simple 创建镜像上述步骤完成后，即可开始构建镜像 1$ docker build '/the/path/to/your/application' build需要一定的时间，完成后，可通过以下命令来查看镜像ID： 1$ docker images 部署最后一步就很简单了，直接全部扔给docker就可以了。使用Docker以daemon方式在生产环境中运行： 1$ docker run -d -p 5000:5000 --name any_name your_image_ID 其中5000:5000为运行的端口号，可自行定义。 一切完成后，flask项目就可正常访问了。 Docker真是个好用的东西 写都写了，顺便不要脸地宣传一下我的大作业NLP(逃","link":"/2020/01/18/docker-deploys-flask/"},{"title":"Java反射","text":"Java的反射机制可以让我们在程序运行时动态构建一个对象，获取对象的属性、构造器以及方法。反射会破坏Java代码的封装性，所以一般只用于框架中。反射用得好，能把JVM掀个底朝天(bushi Java代码如何被运行源代码阶段假若我们当前有一个普通的Java代码： 123456789101112131415public class Wizard { public String name; private double healthPoint; protected double magicPoint; public Wizard() { this.name = &quot;Gandalf&quot;; this.healthPoint = 10; this.magicPoint = 100; } public void enchant(String eleName) { System.out.println(&quot;Generate &quot; + eleName + &quot; element.&quot;); }} 在javac之后，会生成一个Wizard.class文件，这个class文件中主要包含三个部分：成员变量，构造器和成员方法。 12345678910Wizard.class+---------------------------------------+| public String name; || private double healthPoint; || protected double magicPoint; |+=======================================+| public Wizard(){} |+=======================================+| public void enchant(String eleName){} |+---------------------------------------+ 此时我们这个Wizard仍处于源代码阶段，说白了，就还是在硬盘中存着。 类对象阶段众所周知，我们这个Wizard是需要被JVM运行的，那么JVM就需要想办法把我们编译过的Wizard.class加载进去，这个过程是通过ClassLoader，类加载器，来实现的。那么加载进JVM了，现在这个Wizard.class是一个字节码文件，我们得需要一个东西来表示我们当前的Wizard.class吧。这时，JVM会创建一个Class类来对我们的字节码文件进行表示。这块所说的Class类是Java中有个类叫Class，这个Class类用来表示我们的*.class文件，就跟套娃一样。 上面说到，一个*.class字节码文件中主要是三部分：成员变量，构造器和成员方法。那么我们这个Class类，除了需要一些例如类名、编号等属性之外，最主要的肯定是要想办法存储这三个部分。Java同样提供了三个类来表示这三个部分：Field，用来储存成员变量的类；Constructor，用来储存构造器的类；Method，用来储存成员方法的类。 1234567Wizard的Class类对象主要部分+-----------------------------+| Field[] fields; || Constructor[] constructors; || Method[] methods; || (...other minor attrs...) |+-----------------------------+ 因为一个类里会有多个成员变量、构造器以及方法，所以自然需要分别创建一个数组去储存他们。 运行时阶段成功将Wizard.class加载进JVM后，JVM会创建这个对象的实例并给他分配内存空间。这时堆空间内就出现我们的Wizard对象了。 123+--------------+ javac +--------------+ ClassLoader +------------------------+ create object +--------------+| Wizard.java | ----&gt; | Wizard.class | ----------&gt; | Class object of Wizard | ------------&gt; | new Wizard() |+--------------+ +--------------+ +------------------------+ +--------------+ 既然我们的Java代码在JVM中变成了一个Class类对象，那么我们就可以通过这个Class类对象来创建这个Wizard对象，并且可以通过其内部的Field、Constructor和Method对象数组来获取Wizard的属性、构造器以及方法。 Class类对象获取Class类对象主要有三种方式，分别在上述三个不同的阶段来使用。 Class.forName()这个方法用在源代码阶段，也就是说class字节码文件还没有被JVM加载进内存。 通过Class.forName(&quot;类名&quot;)来将字节码文件加载进内存，并返回Class类对象。此处的类名，包括所属的包名，例如org.example.Wizard。 由于此方法需要传入一个字符串作为参数，所以通常用于配置文件。直接从文件中读取类名，然后通过字符串传递来获得到Class对象。 类名.class此方法用在类对象阶段，也就是字节码已经加载进了内存，但还没有创建对象的时候。 此处的class是这个类的一个属性，我们通过类名.class来获取到当前类的class属性，从而获取到Class类对象。 此方法多用于调用方法时进行参数传递。例如SpringBoot在主函数中运行SpringBootApplication时，就需要传递这个类.class给run函数。 对象.getClass()此方法用在运行时阶段，也就是内存中已经有创建完的对象了。 通过对象.getClass()方法来获取当前对象所对应的Class类对象。所有对象都会拥有getClass()方法，此方法被封装在Object对象中。 *.class加载次数那么问题来了，上述三种方式在在同一段代码中应用的话，不同方法获取到的Class对象是否是同一个对象？我们可以用以下代码来做简单的验证： 1234567Class cls1 = Class.forName(&quot;org.example.Wizard&quot;);Class cls2 = Wizard.class;Wizard w = new Wizard();Class cls3 = w.getClass();System.out.println(cls1 == cls2); //trueSystem.out.println(cls2 == cls3); //true 最后我们得到的结果均为true，可见，三种方法在同一次运行过程中，得到的Class对象是同一个对象。也就是说，对于同一个*.class字节码文件，每次运行只被JVM加载一次。当然，前提是JVM用的是同一个类加载器。 FieldJava中对于Field对象的获取，提供了如下几个api： 1234Field getField(String name) // 获取特定的public成员变量对象Field[] getFields() // 获取所有public成员变量对象Field getDeclaredField(String name) // 获取特定的成员变量对象，不受权限修饰符限制Field[] getDeclaredFields() // 获取所有成员变量对象，不受权限修饰符限制 同时，Field对象中提供了相应的get和set方法，可以获取和设置变量具体的值。以我们的Wizard对象为例： 12345Wizard wizard = new Wizard();Class cls = Wizard.class;Field field = cls.getField(&quot;name&quot;);Object value = field.get(wizard); // 获取name值field.set(wizard, &quot;Merlin&quot;); //更改name值 上述代码中，我们需要new一个相应的Wizard对象，并以参数形式传入get和set才能进行变量的获取和更改。这很好理解，有了对象我才能获取和更改，没有对象我get啥set啥？可是对于一个public修饰的属性，似乎根本就不需要反射我们就能进行获取和修改，但是反射机制，能让我们同样获取到非公有属性(private, protected和default）。 1234Wizard wizard = new Wizard();Class cls = Wizard.class;Field field = cls.getDeclaredField(&quot;healthPoint&quot;);Object value = field.get(wizard); 如果我们只是把getField换成getDeclaredField就像获取到非公有属性，在打印value的时候，会碰见如下报错： 1Exception in thread &quot;main&quot; java.lang.IllegalAccessException: class Main cannot access a member of class Wizard with modifiers &quot;private&quot; 这时，我们需要在get之前添加一行： 1field.setAccessible(true); 通过暴力反射，来忽略访问权限修饰符的检查，从而获取到非公有变量的值。对于get方法也同样。 Constructor与Field类似，对于获取Constructor对象，有如下api： 1234Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) // 获取特定的public构造器对象Constructor&lt;?&gt;[] getConstructors() // 获取所有public构造器对象Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) // 获取特定的构造器对象，不受权限修饰符限制Constructor&lt;?&gt;[] getDeclaredConstructors() // 获取所有构造器对象，不受权限修饰符限制 对于获取指定的构造器，我们需要传入改构造器的参数的Class类来指定构造器。假若现在我们的Wizard拥有两个构造器： 1234567891011public Wizard() { this.name = &quot;Gandalf&quot;; this.healthPoint = 10; this.magicPoint = 100;}public Wizard(String name, double healthPoint, double magicPoint) { this.name = name; this.healthPoint = healthPoint; this.magicPoint = magicPoint;} 我们可以通过getConstructor来分别获取两个构造器： 123Class cls = Wizard.class;Constructor c1 = cls.getConstructor();Constructor c2 = cls.getConstructor(String.class, double.class, double.class); 获取构造器的目的，显然就是为了构造一个新对象。在Constructor对象中，Java提供了一个new对象的方法： 1T newInstance(Object... initargs) 实际使用： 12Object wizard = c1.newInstance();Object anotherWizard = c2.newInstance(&quot;Merlin&quot;, 999, 999); 对于无参数的构造器，Java提供了更简便的new对象的方法，不用通过Constructor，Class就可以直接创建对象： 1Object wizard = cls.newInstance(); *但此种方法在Java9之后遭到废弃，建议用Object wizard = cls.getDeclaredConstructor().newInstance()代替。 同样，Constructor中也配备了setAccessible来进行暴力反射的方法。 Method同上，获取Method对象有以下四个api： 1234Method getMethod(String name, Class&lt;?&gt;... parameterTypes) // 获取特定的public方法对象Method[] getMethods() // 获取所有public方法对象Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) // 获取特定的方法对象，不受权限修饰符限制Method[] getDeclaredMethods() // 获取所有方法对象，不受权限修饰符限制 可见，如果要获取特定方法，除了需要传入方法名称之外，还需要传入该方法各参数的Class类，因为方法有可能被重载，名称可能一样，但参数不一样。 获取Wizard类中的enchant方法： 12Class cls = Wizard.class;Method method = cls.getMethod(&quot;enchant&quot;, String.class); 显然，获取方法的目的就是执行它。Method类中提供了一个api来进行方法执行： 1Object invoke(Object obj, Object... args) 调用invoke需要传入指定方法的对象以及调用该方法所需的参数： 12Wizard wizard = new Wizard();method.invoke(wizard, &quot;light&quot;); 继承问题假如现在我们的Wizard继承于Maiar类，Maiar类继承Ainur类，现在我们通过getFields来获取Wizard公有成员变量，我们会发现，Maiar和Ainur的公有变量也均被获取： 123public java.lang.String Wizard.namepublic int Maiar.maiarPublicVarpublic int Ainur.ainurPublicVar 但若通过getDeclaredFields来获取所有成员变量，我们会发现只有Wizard的所有成员变量被获取到了，而Maiar和Ainur并没有： 123public java.lang.String Wizard.nameprivate double Wizard.healthPointprotected double Wizard.magicPoint 对于获取Method，结果也同上: getMethods会获取Wizard, Maiar, Ainur以及Object所有的public方法（因为所有类都继承于Object。同时，Object中无成员变量，所以getFields没有获取到任何关于Object的变量）： 123456789101112public void Wizard.enchant(java.lang.String)public void Maiar.maiarPublicMethod()public void Ainur.ainurPublicMethod()public final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic boolean java.lang.Object.equals(java.lang.Object)public java.lang.String java.lang.Object.toString()public native int java.lang.Object.hashCode()public final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll() 而使用getDeclaredMethods，只能获取到Wizard的所有方法： 1public void Wizard.enchant(java.lang.String) 也就是说，带有Declared的get方法只能获取到当前类的变量和方法，不管是public修饰的还是非public修饰的。而不带有Declared的普通get方法能获取到自己、父类及父类以上的所有public修饰的变量和方法。对于Constructor，不管用什么，都只能获取到当前类的构造器。","link":"/2020/07/12/java-reflection/"},{"title":"完美转发","text":"Reference collapse and perfect forwarding 转发问题假设我们有一个工厂函数，工厂函数里面会new一个对象并返回，并将接受到的参数转发给构造函数： 1234template&lt;typename T, typename S&gt;T* factory(S&amp; arg) { return new T(arg);} 这样实现会有两个问题， S&amp;限制了只能传入一个左值。 func中传入arg是个左值，这样会触发拷贝构造而非移动构造。我们想要传入的引用和转发的引用类型一致。 所以，我们需要一种方案，来实现传入任意左值或右值作为参数，并且在转发参数时不改变其值的类型。 Reference collapsing在c++ 11之前未引入引用折叠时，“引用的引用”这种表示形式是不合法的。但在引入引用折叠后，“引用的引用”这种表达会被编译器翻译掉： T&amp; &amp; –&gt; T&amp; T&amp; &amp;&amp; –&gt; T&amp; T&amp;&amp; &amp; –&gt; T&amp; T&amp;&amp; &amp;&amp; –&gt; T&amp;&amp;也就是说，只有两个右值引用会被折叠为右值引用，其他情况都会折叠为左值引用。 Universal references万能引用是基于引用折叠实现的，其形式和右值引用一样，都是&amp;&amp;。万能引用能同时匹配左值引用和右值引用。 12345678template&lt;typename T&gt;void func(T&amp;&amp; arg) { // do something}int a = 1;func(a); // okfunc(3); // ok 万能引用中只在模板中并且需要类型推导的时候生效，若是特化或者有函数重载的时候，万能引用是无效的。 当传入的是左值引用时，推导后的类型为T&amp;&amp; &amp;，会被折叠为T&amp;；当传入的是右值引用时，推导后的类型为T&amp;&amp; &amp;&amp;，折叠后的类型为T&amp;&amp;。 std::forwardc++11引入了一个新的函数forward来帮助实现完美转发。下面是forward的实现（c++14）： 12345template&lt; class T &gt;constexpr T&amp;&amp; forward( std::remove_reference_t&lt;T&gt;&amp; t ) noexcept;template&lt; class T &gt;constexpr T&amp;&amp; forward( std::remove_reference_t&lt;T&gt;&amp;&amp; t ) noexcept; 注：c++11中为std::remove_reference&lt;T&gt;::type 以传入左值引用为例，当我们特化一个左值引用A&amp;的forward函数时： 123constexpr A&amp; &amp;&amp; forward(typename std::remove_reference_t&lt;A&amp;&gt;&amp; __t) noexcept { return static_cast&lt;A&amp; &amp;&amp;&gt;(__t);} 经过remove reference和引用折叠后，forward变为： 123constexpr A&amp; forward(typename A&amp; __t) noexcept { return static_cast&lt;A&amp;&gt;(__t);} 右值引用依然如此： 123constexpr A&amp;&amp; &amp;&amp; forward(typename std::remove_reference_t&lt;A&amp;&amp;&gt;&amp; __t) noexcept { return static_cast&lt;A&amp;&amp; &amp;&amp;&gt;(__t);} 之后forward变为： 123constexpr A&amp;&amp; forward(typename A&amp; __t) noexcept { return static_cast&lt;A&amp;&amp;&gt;(__t);} 需要注意的是，std::forward只能特例化后使用，不能进行类型推导。 至此，我们一开始的转发问题便得到了解决： 1234template&lt;typename T, typename S&gt;T* factory(S&amp;&amp; arg) { return new T(std::forward&lt;S&gt;(arg));} Reference std::forward C++ Rvalue References Explained","link":"/2021/11/19/perfect-forwarding/"},{"title":"并查集","text":"今天给朋友找资料时，无意中翻出了当年写的Kruskal算法的实现代码。说实话现在再看当年自己写的代码，已经看不懂了。其中在判断选边之后会不会形成闭环回路时，用到了并查集，因为当时是现用现学的，所以还是有些生疏，今天又拿出来翻了翻。说真的，这个结构以及算法是真的简洁实用。 普通并查集并查集，说白了就是一个用数组来表示一个连通图，并且其内部元素构成一种树形结构。它可以用来判断元素之间的连通性，方式是通过判断两个元素是否属于同一个集合。那么如何判断？ 如图可见，有三个集合（3个树)，他们根分别是1，6和8。现在我要判断元素3和元素7是不是在一个集合内，我们只要分别的追溯出他们的根节点，判断他们的根节点是否一致。若一致，则处在一个集合内；若不一致，则不在一个集合内。很显然，对于元素3，其根节点为1；对于元素7，其根节点为6。那么3和7就不在一个集合内。 思想很简单，但最后终归要落实在代码上。为了方便操作，我们让并查集对应的数组满足一定的性质：数组下标i表示集合中的元素i，数组中第i个元素表示集合中元素i的父节点，根节点的父节点为它本身。例如：S[7]=6表示集合中的元素7的父节点为元素6；S[6]=6表示集合中的元素6的父节点为元素6自身，这表明6为根节点。 以上图中最左面的集合为例，在数组中它表示为：S[1]=1, S[2]=1, S[3]=2, S[4]=3, S[5]=3。 那么，对于查找根节点的操作，可以用下面的Find函数来实现： 1234567SetType Find(SetType X){ if (S[X] == X) return X; //若是根节点，返回 else return Find(S[X]); //若不是根节点，递归寻找} 对于合并操作的代码： 123456void SetUnion(SetType X, SetType Y){ SetType Root1 = Find(X), Root2 = Find(Y); if(Root1 == Root2) return; S[Root2] = Root1;} 对于某一类问题，如果它并不需要连通图中每个节点的具体信息，只需要获得图中连通节点的数量或者需要用图的连通性去判断一些其他条件时，并查集相比其他图的表示方式是最佳的选择。 按秩优化最简单的并查集很好实现。原理可能有些不容易懂，但代码很简洁。实在不行就背但上述代码实现可能会造成一个问题，就是所有节点都集中在树的一侧：在上述的Find函数中，我们可以看出对于根节点的寻找是需要一个一个往回追溯的，树越高，节点越多，所耗费的时间越大。 这里探讨其中一种优化思路：按秩优化。 其思想也很简单，由于对于根节点的寻找是需要一个一个往回追溯的，那么自然树越小，所耗费的时间就越小。那么我们在合并两个集合的时候，尽量把小树往大树上合并。 还是这两个集合，很明显，左树的规模大于右树，若我们将节点6接在节点8下，新树的高度相比左树还增加了1；若我们将节点8接在节点6下，新树的高度仍是左树的高度。此处可以证明，如果合并操作都是按大小进行的，那么任何节点的深度均不会超过$logN$。 形式一由上述可见，此优化的核心是记录各个集合树的大小并作比较。在此，我们增加一个大小等同于并查集数组S的数组Rank来记录每个元素作为根节点时树的大小。 除按高度外，也可以将树的高度作为rank来进行合并。很明显，按高度合并是按大小合并的一种简易版，因为只有两个高度相等的树合并时秩才会增加，这样代码会更加简洁。与上述相似，只是将rank中的值改为树的高度。此处给出的代码是按高度合并。不要问为什么不写按大小合并，因为那个写起来更麻烦 12345678910111213void SetUnion(SetType X, SetType Y){ SetType Root1 = Find(X), Root2 = Find(Y); if(Root1 == Root2) return; if (Rank[Root2] &gt; Rank[Root1]) S[Root1] = Root2; else { if (Rank[Root1] == Rank[Root2]) //两个集合高度一致，随便挑一个将其接在另一个上 Rank[Root1]++; S[Root2] = Root1; }} 上面已经讲到，对于按高度合并，只有两个高度相等的树合并时秩才会增加，而且每次增加只会+1。所以在上述代码中，只有在Rank1等于Rank2时，我们才将秩+1。若是采用按大小合并，每次合并操作都需要更新根节点的Rank值，相较之下就麻烦了许多。 形式二但上述这么写的弊端是需要额外申请一个数组的空间。在此提供一个简易的写法：对于根节点，其对应的数组元素中我们不再存储它本身，而是存储秩，即树的高度或大小。此处给出的代码仍是按高度合并： 12345678910111213void SetUnion(SetType X, SetType Y){ SetType Root1 = Find(X), Root2 = Find(Y); if(Root1 == Root2) return; if (S[Root2] &lt; S[Root1]) S[Root1] = Root2; else { if (S[Root1] == S[Root2]) S[Root1]--; S[Root2] = Root1; }} 上述代码中的秩是以一个负值来表示的。其中需要注意的是，若采用此种方式，在初始化集合的时候，每个元素对应的值应该为-1，因为每个节点在初始化时都是一棵树，而这些树的高度均为1。在我的Kruskal算法中就采用的此种方式，但其实我当时根本不知道什么是按秩优化。 两种按秩优化方式的复杂度均为最坏情况下树的高度，即$O(log_2N)$。 路径压缩对于上述一个串类型的树，我们还可以采用路径压缩的优化方式。其核心思想相比按秩优化稍有些复杂：在我们第一次追溯根节点的过程中，其实我们已经隐式地知晓了某个节点是否是根节点。那么我们是否可以在追溯的过程中，将树做一些改变，这样在下一次查找的过程中就可省下一些时间？ 其核心步骤为：将操作节点接在其父节点的父节点上。 这样有些难以理解，咱们来举个例子。对于下面这样的并查集：假设我们此次操作是查找元素4的根节点，那么我们第一次查找S[4]发现S[4]的值为3，说明4不是根节点，那么我们在递归节点3的同时，将4接在其父节点的父节点上，也就是节点2：下一次递归时，我们操作的是节点3。同样，我们将其接在父节点的父节点上，也就是节点1：下面是节点2，将2接在其父节点的父节点上。注意，2的父节点是1，1此处没有父节点了，但我们在一开始说过，并查集的数组结构中，根节点的父节点是其本身，所以结果仍是将2接在1上，树的结构并没有改变。这也是为什么我在按秩优化中不推荐第二种写法的原因，因为在第二种写法中，S[Root]中存储的不是Root本身，而是树的高度。 可见，经过一次路径压缩后，我们的集合树变矮了，这样若下次仍查找元素4，就可以少遍历一次。 代码实现：（其中并查集数组结构为一开始介绍的形式：根节点对应的数组元素中存储的是其本身，即S[X]=X，其中X为根节点） 1234567SetType Find(SetType X){ if (S[X] == X) return X; //若是根节点，返回 else return S[X] = Find(S[X]); //若不是根节点，递归寻找。同时更改树的结构} 此外，我曾在大佬的文章中见识过一种更加简洁🐂👃的压缩路径写法： 1234SetType Find(SetType X){ return X==S[X]?X:S[X]=Find(S[X]);} 一行解决并查集，无话可说。 需要注意的是，若你的并查集数组采用的结构是上一部分中最后介绍的形式，即根节点对应的数组元素中存储的不是其本身，而是秩的话，需要对路径压缩代码进行些许更改： 1234567SetType Find(SetType X){ if (S[X] &lt;= X) //此处进行了更改。通过检验S[X]中的值是否为负来判断X是否为根节点，而非检验S[X]是否为X本身。 return X; else return S[X] = Find(S[X]);} 维基百科上有给出，单使用路径压缩时，时间复杂度是一个很复杂的式子，为$$Θ(n+f·(1+log_{2+f/n}n))$$在Mark Allen Weiss的书上给出，连续M次操作最多需要$O(MlogN)$的时间。 按秩优化+路径压缩很明显，按秩优化优化的是SetUnion函数，路径压缩优化的是Find函数，我们显然可以将两种优化合并使用（其中按秩优化为按高度合并。且并查集的结构为第一种形式。）： 123456789101112131415161718192021SetType Find(SetType X){ if (S[X] == X) return X; //若是根节点，返回 else return S[X] = Find(S[X]); //若不是根节点，递归寻找。同时更改树的结构}void SetUnion(SetType X, SetType Y){ SetType Root1 = Find(X), Root2 = Find(Y); if(Root1 == Root2) return; if (Rank[Root2] &gt; Rank[Root1]) S[Root1] = Root2; else { if (Rank[Root1] == Rank[Root2]) //两个集合高度一致，随便挑一个将其接在另一个上 Rank[Root1]++; S[Root2] = Root1; }} 路径压缩和按秩序优化的兼容性可见，若秩为树的大小，路径压缩和按秩优化是完全兼容的。因为路径压缩针对的是查询函数，而按秩优化针对的是合并函数，最重要的是两种优化方法并没有相互冲突之处，只需同时使用即可。 但是对于秩为树的高度的合并方法（即上一部分给出的），两者并不完全兼容，因为路径压缩会改变树的高度。这样就难以取计算他们的效率。 两者同时使用时，算法在最坏的情况下基本是线性的，其需要的时间为$O(α(n))$。在维基百科的解释中，$α(n)$为$A(x, x)$的阿克曼函式，就结果来讲，$α(n)$在n很大时整体仍小于5。","link":"/2020/02/29/disjoint-sets/"},{"title":"关于Flask浏览器缓存问题","text":"最近写大作业需要用到Flask框架，但使用时发现一个致命问题。 起因是我在修改css文件后，重新运行项目，发现前端并没有更改。 原因是在编写前端时，通常会把图片、css、js等文件放在static文件夹下。但这同时也导致了一个问题：在浏览器加载网页时，会留有一份缓存。当重新运行项目，浏览器并没有向后台请求新的样式文件，而是直接加载的缓存。 正常人最初的想法肯定都是把浏览器缓存关掉。但不知为何，我的小chrome不吃这套（摊手。而且把浏览器缓存关掉也不是一个明智的选择。 之后浏览了不少的博客，大多数给出的方法是更改flask的缓存机制，flask配置文件中默认的缓存有效时间是12h。然而直接更改flask设置并不是一个合适的方法。有的博客给出了在项目中的python中的文件中进行此项设置的更改。然而我的小项目也不吃这套（再次摊手。 无奈之下，只能改用最笨的方法：既然浏览器不对后台进行请求，那就让他强行请求就好了。 核心想法是动态更改html中的url，每次请求的url不一样，浏览器便不会加载缓存 于是，在html文件中引入css时，可以采用这种方式： 1&lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static', filename='assets/css/main.css', v=0.0129)}}&quot; &gt;; 每次更改样式文件后，手动更改一下或动态生成版本号，这样浏览器发现版本号对不上后就会重新请求一份。 也可采用时间戳的方式。时间戳的好处在于能够避免重复。 例如我加载本地的图片时，可采用以下方式引入时间戳： 12path = &quot;static/wordcloud.png?timestamp=&quot;+new Date().getTime(); //在图片路径后加入时间戳html = '&lt;img src=&quot;'+path+'&quot; alt=&quot;wordcloud&quot;&gt;'; 我承认这个方法很笨，但真的立竿见影 果然，笨方法永远是最好用的。","link":"/2019/12/11/cache-in-flask/"},{"title":"新年快乐","text":"明けました！ 新的一年从老婆的问候开始 gakki给的照片还是那么高糊","link":"/2019/12/31/happy-new-year/"},{"title":"添加Valine评论功能","text":"想着给自己博客加个评论功能，奈何主题作者没有给出设置选项，只能自己摸索着配置。 此评论功能采用的是Valine。虽然我更喜欢来必力 注册LeanCloud首先需要注册一个LeanCloud账号。随便添加一个应用后，可在设置中查看AppID和AppKey。 添加配置打开themes中的_config.yml文件，添加Valine相关配置： 123456valine: appid: #你的AppId appkey: #你的AppKey verify: true #验证码 notify: true #评论回复提醒 placeholder: 欢迎留言 #评论框占位符 创建ejs文件在/layout/_plugins文件夹下创建名为valine.ejs的文件，并写入下面的代码： 123456789101112131415&lt;div class=&quot;valine_comment&quot;&gt;&lt;/div&gt;&lt;!--Leancloud 操作库:--&gt;&lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;&lt;!--Valine 的核心代码库--&gt;&lt;script src=&quot;//unpkg.com/valine/dist/Valine.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Valine({ el: '.valine_comment', app_id: '&lt;%= theme.valine.appid %&gt;', app_key: '&lt;%= theme.valine.appkey %&gt;', placeholder: '&lt;%= theme.valine.placeholder %&gt;', notify: '&lt;%= theme.valine.notify %&gt;', verify: '&lt;%= theme.valine.verify %&gt;', });&lt;/script&gt; 添加调用Valine代码之后需要在相应的生成文章样式的ejs代码中添加调用代码，主题不同位置也会有所不同，我的主题是在layout/_page/post.ejs中添加： 123456789101112131415&lt;section&gt; &lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey){ %&gt; &lt;section id=&quot;comments&quot; class=&quot;comments&quot;&gt; &lt;style&gt; .comments{margin:30px;padding:10px;background:#fff} @media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#fff}} &lt;/style&gt; &lt;%- partial('_plugins/valine', { key: post.slug, title: post.title, url: config.url+url_for(post.path) }) %&gt; &lt;/section&gt; &lt;% } %&gt;&lt;/section&gt; 之后就可以部署进行测试了。","link":"/2019/12/12/add-valine-comments/"},{"title":"索引与B+树","text":"为什么InnoDB使用B+树作为索引的数据结构？ 为什么不用哈希表？众所周知，哈希表理想的插入和查询时间复杂度为$O(1)$，也就是说，如果不发生冲突，哈希表就是永远滴神。那么为什么哈希表不是理想的索引结构？ 1SELECT * FROM User WHERE id = 1; 假如是这么一个SQL语句，那么用哈希表作为id列的索引可以说几乎是完美的。因为id一般来说都是主键，id为1的行肯定只有1个。 1SELECT * FROM User WHERE id &gt; 1; 但假若是这么一个需要进行范围搜索的SQL命令，哈希表就白给了，因为对于id&gt;1这么一个范围条件来讲，你哈希函数怎么做映射？ InnoDB是存在自适应哈希索引的，但正如上述所说，对于字典型，哈希索引效率是很高的，但对于范围性搜索，哈希表是无能为力的。 为什么不用AVL？哈希表不理想，是因为无法较好支持范围查询，但二叉树可以啊。那为什么InnoDB也没有采取此种方式？ 这是一个插入了1-10的AVL树，假设我们运行下面这个SQL 1SELECT * FROM User WHERE id &gt; 5; 在AVL中，先锁定节点5的位置，所有大于5的节点都分布在它的右方。那么我们在进行查询的时候，就需要DFS来对所有键值大于5的节点进行访问并输出，那么这显然会增加磁盘的随机I/O次数，因为我们不可能把整个索引结构全加载进内存，所以这种索引查找避免不了频繁的磁盘I/O，磁盘随机I/O的时间消耗可是致命的，这种徒增I/O消耗的方法对于数据库来讲肯定是不可取的。 为什么不用B树？减少上述I/O次数的一种办法就是降低树的高度，怎么降低高度？每个节点多存点数据就行了。B树就这么诞生了。 这是一个max degree为3的B树，同样是插入1-10，B树的高度要小于AVL树。但这依然解决不了需要DFS的问题，随机I/O消耗依旧不小。 那为什么就用B+树了？ 上图是一个max degree也为3的B+树，B+树不同于B树的地方就在于所有数据都存在于叶子节点，非叶子节点只包含键值，不包含数据。最早在数据结构课上看到B+树的时候，我一直不明白这东西存在的意义是什么，同样的数据同样的max degree，B+树的高度明显要比B树大，那为什么InnoDB会采用B+树？还是因为随机I/O的问题，B+树所有的叶子节点会构成一个链表结构，每个节点都拥有指向下一个节点的指针，这样在进行范围搜索的时候，B+树就可以直接在叶子节点之间进行跳转，这样大大减少了磁盘I/O的所消耗的时间。同时，若链表数据能够连续存储，不但节省I/O，还能保证数据在逻辑上和物理上都是相邻的，这恰恰适用于局部性原理，对于内存页表的缓存非常友好。 索引失效B+树用于索引的优势就在于1）二分查找加速查找时间。2）叶子节点按顺序排列，链表结构优化范围查找。所以但凡SQL语句的查询条件使得查询时无法遵守叶子节点的排列顺序，索引就失效了。 带OR的SQL当SQL的条件带有OR关键字，自然查找就不会遵循叶子节点的排列顺序，因为OR连接的两个条件所对应的叶子节点在B+树的叶子链表中不一定是连续的，如果是跳跃的，B+树自然就没用了，就只能全表扫描进行查找。 组合索引如果索引是组合索引，例如下图的B+树叶子节点链表： 123+-------+ +-------+ +-------+ +-------+ +-------+ +-------+| (1,2) | -&gt; | (1,3) | -&gt; | (1,5) | -&gt; | (2,1) | -&gt; | (2,3) | -&gt; | (3,1) |+-------+ +-------+ +-------+ +-------+ +-------+ +-------+ 可见，叶子节点的排列顺序是先排列第一个key，再排列第二个key，如果只用key2作为条件： 1SELECT * FROM User WHERE key2&gt;2; 因为在叶子节点中，key2的排列顺序是依赖于key1的，只看key2的话，key2是无序的。所以如果单纯只以key2来作为条件，搜索时无法按照叶子节点的链表顺序来进行查找，索引失效。 但假如先设置key1条件，再设置key2条件： 1SELECT * FROM User WHERE key1=1 AND key2&gt;2; 这样是符合链表顺序的，索引就不会失效。 如果把key2和key1顺序颠倒，会先去搜寻符合key2条件的节点，再去搜寻也符合key1的节点。但是组合索引的顺序是(key1, key2)，顺序依然会被打乱，所以索引仍会失效。例如： 1SELECT * FROM User WHERE key2=1 AND key1=1; 如果key1的条件是一个范围，即使遵循先key1再key2的顺序，索引依然会失效。例如： 1SELECT * FROM User WHERE key1&gt;1 AND key2=1; 原因也很显然，因为key1&gt;1筛选出来的是一个范围，在这个范围内，key2仍是无序的，所以依然会造成遍历部分链表。 为了避免组合索引下的索引失效，需要SQL中的条件语句遵守最左前缀法则，即，条件语句中的各条件顺序应按照组合索引的顺序，且在最后一个条件之前不得出现范围查询（&gt;, &lt;, between, in等）。例如上面第二个SQL语句，只有最后对于key2的条件是指定范围。 like模糊搜索like后的字符串模糊匹配分为前缀、中缀和后缀三种，即，str%，%str%，%str。对于判断哪种会造成索引失效，同上面的思路，只要保证搜索时能按照叶子节点的链表顺序，就不会出现整表搜索的情况。对于字符串类型的数据，其叶子节点是按照字典序来排列的，那么答案就很明朗了，只有前缀，即str%这种形式的模糊搜索是不会破坏索引的，其余的中缀和后缀，都无法保证字典序搜索，自然会造成索引失效。 对索引列进行运算或者函数操作如果对索引列的数据进行了一些运算操作或者函数操作，其结果值自然无法应用于现有的B+树结构，索引自然也就失效了。 参考 What is the difference between Mysql InnoDB B+ tree index and hash index? Why does MongoDB use B-tree? 浅谈MySQL的B树索引与索引优化 数据结构可视化","link":"/2020/09/12/index-and-b+tree/"},{"title":"移动语义","text":"Left value, Right value and Move Semantics 右值引用虽然c++11对value catagories进行了新划分，但最初c++沿用了c对于一个表达式的分类，只有左值(lvalue)和右值(rvalue)，能获取内存地址的就是左值，不能的就是右值。对于左值的引用就是左值引用，对于右值的引用就是右值引用。 123int val = 6;int&amp; lref = a; // left value referenceint&amp;&amp; rref = 6; // right value reference 严格来讲，左值引用不能引用右值，右值引用不能引用左值，但是添加了const限定的左值引用可以引用右值： 1const int&amp; lref = 6; 拷贝构造假设我们现在有一个简单的对象，对象里有一个整型数组和一个记录数组大小的变量： 123456789101112131415161718192021class Array {private: size_t size_; int* data_;public: explicit Array(const size_t size): size_(size), data_(new int[size_]) {} ~Array() { std::cout &lt;&lt; &quot;deconstructing&quot; &lt;&lt; std::endl; if (data != nullptr) { delete[] data_; size_ = 0; } } // copy assginment constructor Array(const Array&amp; other): size_(other.size_), data_(new int[size_]) { std::cout &lt;&lt; &quot;deep copying&quot; &lt;&lt; std::endl; std::copy(other.data_, other.data_ + size_, data_); }}; 在第二个拷贝函数中，我们传入了另一个Array对象并试图把该Array对象中的数据拷贝进入当前构造的对象当中去。很显然，这个传入的Array是一个左值，引用便是左值引用，同时构造函数中需要深拷贝。但假若我需要拷贝一个很大很复杂的对象，深拷贝的代价就会非常大。显然，我们需要一个更好的方法，比如是否可以直接把传入的Array对象里的数据直接拿过来，而非拷过来？ 移动构造这个时候右值引用就派上用场了。因为右值没有地址，可以直接复制给左值，那么只要传入一个右值在进行赋值就可以避免深拷贝了。 123456// move assignment constructorArray(Array&amp;&amp; other): size_(other.size_), data_(other.data_) { std::cout &lt;&lt; &quot;move constructor&quot; &lt;&lt; std::endl; arr.data_ = nullptr; arr.size_ = 0;} 这时我们只要在构造中传入一个右值，就可以进行内存所有权的转移，从而避免进行深拷贝，进而减少性能消耗。同时，在移动构造中一定要释放源对象的指针，防止析构重复释放内存。 赋值运算符赋值运算符也可以用移动语义来优化。 123456789101112131415161718192021222324252627282930// copy assignment operator.Array&amp; operator=(const Array&amp; other){ std::cout &lt;&lt; &quot;Copy operator&quot; &lt;&lt; std::endl; if (this != &amp;other) { delete[] data_; size_ = other.size_; data_ = new int[size_]; std::copy(other.data_, other.data_ + size_, data_); } return *this;}// move assignment operator.Array&amp; operator=(Array&amp;&amp; other){ std::cout &lt;&lt; &quot;Move operator&quot; &lt;&lt; std::endl; if (this != &amp;other) { // free exsiting memory. delete[] data_; size_ = other.size_; data_ = other.data_; other.data_ = nullptr; other.size_ = 0; } return *this;} std::move()还有一个问题没有解决，就是如何传入一个右值。c++在std中提供了一个move函数，这个函数虽然叫move，但它的功能非常简单，就是单纯的把一个左值变为右值。说白了，就是对static_cast&lt;T&amp;&amp;&gt;进行的封装。 12// For an existing Array object AArray B(std::move(A)); 此处A是一个左值，我们希望调用移动构造器，便使用move将A变为右值并传入。传入后A的内存数据被直接转移给了B，A中的内容被置空，等待析构。 此外，std::move()一般不用于基本类型，基本类型没有必要进行内存移动，移动速度不一定比拷贝快。 Reference Understanding lvalues and rvalues in C and C++ What is move semantics? Move Constructors and Move Assignment Operators (C++)","link":"/2021/10/16/move-semantics/"},{"title":"控制反转和依赖注入","text":"学Spring的时候，接触到两个比较重要的概念，一个是IoC（Inversion of Control），控制反转；一个是DI（Dependency Injection），依赖注入。 工厂和单例解耦在一个简易的后端项目中，处理三层架构最简单的方式自然就是视图层中new业务层的对象，业务层中又new持久化层的对象。但这样下来，耦合度很高，因为这样导致了编译时需要处理各类之间的依赖关系。一个最直接的解耦方式，就是利用读取配置文件，再进行反射，在运行时创建实例对象来取代new，这样能够剥离各层之间的依赖关系。 首先将需要反射的全类名存储在一个简易的properties文件中： 12service=org.example.service.impl.ServiceImpldao=org.example.dao.impl.DaoImpl 配置文件写好了，现在我们需要去读取这个配置文件，然后通过反射来进行实例创建。此过程最好放置在一个工厂类中，通过工厂模式来进一步解耦。 12345678910111213public class MyBeanFactory { private static Properties props; static { props = new Properties(); try { InputStream in = MyBeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;); props.load(in); } catch (Exception e) { throw new ExceptionInInitializerError(&quot;Fail to load properties files.&quot;); } }} 上述代码中，在调用Properties对象的load方法之前，并没有通过指定一个路径来创建InputStream对象，而是通过MyBeanFactory.class.getClassLoader().getResourceAsStream()来获取。因为对于properties文件，我们一般是放在resources目录下，但若是直接指定路径，在项目部署后，是无法通过指定resources路径来获取到文件的。 之后，我们在MyBeanFactory类中添加一个创建实例的方法来完成我们的工厂类： 12345678910public static Object getBean(String beanName) { String path = props.getProperty(beanName); Object bean = null; try { bean = Class.forName(path).getDeclaredConstructor().newInstance(); } catch (Exception e) { e.printStackTrace(); } return bean;} 现在，我们就可以用MyBeanFactory.getBean()来代替各层中的new了。 但还有一个问题，假如我们在视图层内创建了多次某个业务层的Bean，这样创建出来的这些Bean是多例状态，有时我们希望这些创建出来的Bean是同一个Bean对象，这时我们就需要引入单例模式。 思路很简单，在MyBeanFactory中添加一个哈希表，来存储各个properties文件中的value值所对应的实例对象，之后的getBean()函数，不再进行实例创建，而是直接从这个哈希表中进行查找。下面是更改后的MyBeanFactory，为了方便，简单写了一个饿汉式单例： 123456789101112131415161718192021222324252627public class MyBeanFactory { private static Properties props; private static HashMap&lt;String, Object&gt; beans; static { props = new Properties(); try { InputStream in = MyBeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;); props.load(in); // Singleton beans = new HashMap&lt;&gt;(); Enumeration keys = props.keys(); while(keys.hasMoreElements()) { String key = keys.nextElement().toString(); String path = props.getProperty(key); beans.put(key, Class.forName(path).getDeclaredConstructor().newInstance()); } } catch (Exception e) { throw new ExceptionInInitializerError(&quot;Fail to load properties files.&quot;); } } public static Object getBean(String beanName) { return beans.getOrDefault(beanName, null); }} 控制反转现在来说正题，IoC。IoC（Inversion of Control），控制反转，是Spring框架的核心之一。在上述例子中，我们将new替换成了利用MyBeanFactory来创建实例，以业务层中创建持久化层的对象的具体代码为例，我们可以将 1Dao dao = new DaoImpl(); 替换成 1Dao dao = (DaoImpl)MyBeanFactory.getBean(&quot;dao&quot;); 在第一种写法中，我们创建实例对象的控制权仍处于我们的应用中，这使得各模块之间的依赖变强，大大增加了耦合度。 123456789 +----------+ +---&gt; | Resource | | +----------++-----+ | +----------+| App | --------&gt; | Resource |+-----+ | +----------+ | +----------+ +---&gt; | Resource | +----------+ 而在第二种写法中，我们将控制权交给了工厂，工厂会自动创建对应的实例并返回给应用。 123456789 +----------+ +---&gt; | Resource | | +----------++-----+ +---------+ | +----------+| App | &lt;-------&gt; | Factory | --------&gt; | Resource |+-----+ +---------+ | +----------+ | +----------+ +---&gt; | Resource | +----------+ 下面是维基百科中对于控制反转的定义： In software engineering, inversion of control (IoC) is a programming principle. IoC inverts the flow of control as compared to traditional control flow. In IoC, custom-written portions of a computer program receive the flow of control from a generic framework. 控制反转的核心在于将创建对象的控制权交给框架而非具体组件。很明显，IoC是一种DIP原则的实现思路。 依赖注入依赖注入，Dependency Injection(DI)，是一种IoC的具体实现方式。 IoC是一种基于DIP原则的思路，将实例的控制权全部交给了框架，应用组件本身不会去创建管理实例。而DI，为IoC提供了一种具体的方法：现在各组件之间的依赖全权由框架负责，框架通过注入的方式，将各组件所需的资源提供给该组件。依赖注入大大增强了各模块可重复使用性，使得整个应用更加灵活，因为各组件之间不再存在强依赖，依赖是框架注入给组件的，组件本身不需要管理依赖。而且若需要更改依赖的注入，只需对配置文件稍作更改即可，无需任何代码。 关于DI和IoC，两者总是有些含糊不清，容易混淆在一起。简单来讲，两者是描述的同一个思想的不同角度。就Spring来讲，Spring框架会提供IoC容器，类似于第一部分我们手撕出来的工厂，他负责的是Bean的生命周期控制。这就是IoC，描述了一种将Bean的生命周期管理全权交给IoC容器的思想。但是，IoC究竟要怎么去创建一个Bean呢，这就需要DI了。DI描述的是框架究竟该通过何种方式去创建这个实例。 Spring中基于XML的IoC容器基本xml配置第一部分中我们手撕了一个MyBeanFactory来实现控制的反转，但是在Spring框架中，已经集成了相关功能。Spring框架中的配置文件使用的不是properties而是xml，我们需要在resources文件夹下创建一个xml文件来作为我们的配置文件，具体格式如下，也可以参照Spring的官方文档： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; 例如我需要根据我的各个dao对象来对xml文件进行配置，只需创建一个dao.xml，然后在其中进行如下配置： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;org.example.dao.impl.AccountDaoImpl&quot;&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id=&quot;itemDao&quot; class=&quot;org.example.dao.impl.ItemDaoImpl&quot;&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for data access objects go here --&gt;&lt;/beans&gt; 在使用的时候，我们需要首先获取IoC容器对象： 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;dao.xml&quot;); 这个容器对象就相当于第一部分我们手撕的工厂类，同时，此容器对象中同样提供了getBean()方法。 Bean创建方法上面这种&lt;bean id=&quot;itemDao&quot; class=&quot;org.example.dao.impl.ItemDao&quot;&gt;&lt;/bean&gt;标签只能根据默认构造函数进行实例创建。（注意，JavaBean规范中要求必须提供一个无参数的默认构造函数）若此时我们有一个外部jar包，假设其中有一个工厂类，我们需要根据工厂类中的特定方法来获取实例对象，可以用下面的标签： 12&lt;bean id=&quot;instanceFactory&quot; class=&quot;org.example.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;accountDao&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountDao&quot;&gt;&lt;/bean&gt; 这样，我们就可以通过InstanceFactory这个类中的getAccountDao方法来获取到我们需要的AccountDao这个对象了。 若此时的外部工厂类中的获取特定实例对象的方法是一个静态方法，我们可以用下面的标签来进行代替： 1&lt;bean id=&quot;accountDao&quot; class=&quot;org.example.factory.StaticFactory&quot; factory-method=&quot;getAccountDao&quot;&gt;&lt;/bean&gt; scope属性&lt;bean&gt;标签还有一个scope属性，此属性用于描述Bean的作用范围，取值有5个： singleton：单例，缺省值 prototype：多例 request：web应用的请求范围 session：web应用的会话范围 global-session：若存在负载均衡，作用于整个集群的会话范围。若无集群，等同于session。 Bean生命周期ApplicationContext创建的Bean无非两种，单例和多例。 对于单例对象，随着容器创建而创建，随着容器销毁而销毁。生命周期同容器的生命周期。 对于多例对象，总是延时创建的，也就是说，容器创建的时候对象并不会被创建，只有需要使用该对象的时候才会被创建。并且也不会随着容器销毁而销毁，只要被使用，就会一直存在。当不再有引用时，被gc回收。 Spring中基于XML的DI注入的方式大体有两种： 构造函数注入 set方法注入 能够进行注入的对象大体有以下几种： 基本类型的包装类和String 配置过的Bean 集合类 构造函数注入假设我们现在有一个类，（随便写的一个类，没有什么具体含义），他有一个三个参数的构造函数。 1234567891011public class Clazz { private Integer num; private String str; private Date date; public Clazz (Integer num, String str, Date date) { this.num = num; this.str = str; this.date = date; }} 现在我们要通过注入来根据这个构造函数创建实例。在Spring的xml配置文件中，提供了一个&lt;constructor-arg&gt;标签来进行构造函数注入的相关配置。此标签需用在&lt;bean&gt;标签下： 123&lt;bean id=&quot;exampleClass&quot; class=&quot;org.example.Clazz&quot;&gt; &lt;constructor-arg&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 之后，我们需要通过该标签的相关属性，来进行参数的传递。&lt;constructor-arg&gt;有如下几个属性： type：指定注入数据的类型，与构造函数中的参数类型对应。 index：指定注入数据在构造函数的参数列表中的位置，从0开始。 name：指定注入数据在构造函数的参数列表中的名称。 value：注入数据的具体值。均为字符串，Spring会根据构造函数来进行具体的类型转换。 ref：用于指定其他Bean类型。 可见，type，index和name是用来指定注入哪个参数的。但type是无法唯一确定需要注入的参数的，因为一个构造函数中可能存在多个同类型的参数。而name是可以唯一指定的，因为参数名称是无法重复的。所以一般来讲，只用name属性就足够进行参数指定了。 12345&lt;bean id=&quot;exampleClass&quot; class=&quot;org.example.Clazz&quot;&gt; &lt;constructor-arg name=&quot;num&quot; value=&quot;6&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;str&quot; value=&quot;hello&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;date&quot; value=&quot;2020-01-01&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 假如我们进行上述的注入配置，在运行之后，会生成报错： 1Exception in thread &quot;main&quot; org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'exampleClass' defined in class path resource [dao.xml]: Unsatisfied dependency expressed through constructor parameter 2: Could not convert argument value of type [java.lang.String] to required type [java.util.Date]: Failed to convert value of type 'java.lang.String' to required type 'java.util.Date'; 可见，Spring成功将字符串&quot;6&quot;转换成了整型6，但是无法将日期字符串转换成日期对象。因为日期对象并非基本类型的包装对象，Spring自然无法自行转换。这时我们需要额外配置一个Date类型的Bean来进行指代，这时候我们的ref属性就派上用场了： 123456&lt;bean id=&quot;exampleClass&quot; class=&quot;org.example.Clazz&quot;&gt; &lt;constructor-arg name=&quot;num&quot; value=&quot;6&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;str&quot; value=&quot;hello&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;date&quot; ref=&quot;exampleDate&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=&quot;exampleDate&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; 如果需要创建一个特定日期的Date对象的话，可以使用上面Bean的创建方法中提到的利用指定方法来创建一个Bean对象，此处我们可以用SimpleDateFormat中的parse方法。这时会比较麻烦，需要在&lt;constructor-arg&gt;内再套一个&lt;bean&gt;标签，并在这个&lt;bean&gt;标签内使用&lt;constructor-arg&gt;来进行给parse方法传参： 12345678910111213&lt;bean id=&quot;exampleClass&quot; class=&quot;org.example.Clazz&quot;&gt; &lt;constructor-arg name=&quot;num&quot; value=&quot;6&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;str&quot; value=&quot;hello&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;date&quot;&gt; &lt;bean factory-bean=&quot;exampleDate&quot; factory-method=&quot;parse&quot;&gt; &lt;constructor-arg value=&quot;2020-01-01&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=&quot;exampleDate&quot; class=&quot;java.text.SimpleDateFormat&quot;&gt; &lt;constructor-arg value=&quot;yyyy-MM-dd&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; setter注入顾名思义，setter注入无非就是给构造函数的参数分别各写一个set方法，然后通过set方法注入。对于上述的Clazz类，我们写如下几个setter： 1234567891011public void setNum(Integer num) { this.num = num;}public void setStr(String str) { this.str = str;}public void setDate(Date date) { this.date = date;} 这时，在&lt;bean&gt;标签内，需要额外添加&lt;property&gt;标签，每一个&lt;property&gt;标签对应一个setter。&lt;property&gt;标签的属性有如下三个： name：注入时调用的setter名称。具体的属性值是setter名称去掉’set’，且后面第一个大写字母均变为小写。例如，setUserName()对应的属性值为’userName’。 value：注入数据的具体值。均为字符串，Spring会根据构造函数来进行具体的类型转换。 ref：用于指定其他Bean类型。 除了name用法不同，value和ref用法同构造函数注入。 123456&lt;bean id=&quot;exampleClass&quot; class=&quot;org.example.Clazz&quot;&gt; &lt;property name=&quot;num&quot; value=&quot;6&quot;&gt;&lt;/property&gt; &lt;property name=&quot;str&quot; value=&quot;hello&quot;&gt;&lt;/property&gt; &lt;property name=&quot;date&quot; ref=&quot;exampleDate&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;exampleDate&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; 很明显，相比构造函数注入，setter注入要灵活的多，它不需要一次性注入全部的变量就可以创建实例。但是它也有弊端，setter注入是无法保证获取到的对象中每个属性都有值。 注入集合类对于一些常用的集合类，例如Array，List，Map，Set和Properties。他们的注入需要额外的标签，而且只能用构造器注入和setter注入。 现在我们在Clazz类中加入这些类型的属性变量： 123456789101112131415161718192021222324252627public class Clazz { private String[] strArray; private List&lt;String&gt; strList; private Map&lt;String, String&gt; strMap; private Set&lt;String&gt; strSet; private Properties props; public String[] getStrArray() { return strArray; } public List&lt;String&gt; getStrList() { return strList; } public Map&lt;String, String&gt; getStrMap() { return strMap; } public Set&lt;String&gt; getStrSet() { return strSet; } public Properties getProps() { return props; }} 由于构造函数注入和setter注入大同小异，下面只以setter注入为例。 对于这些复杂的集合类的注入，我们需要使用&lt;property&gt;或&lt;constructor-arg&gt;下的一些子标签： 123456789101112131415161718192021222324252627282930313233343536373839&lt;bean id=&quot;exampleClass&quot; class=&quot;org.example.Clazz&quot;&gt; &lt;!-- 数组注入 --&gt; &lt;property name=&quot;strArray&quot;&gt; &lt;array&gt; &lt;value&gt;A&lt;/value&gt; &lt;value&gt;B&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- List注入 --&gt; &lt;property name=&quot;strList&quot;&gt; &lt;list&gt; &lt;value&gt;C&lt;/value&gt; &lt;value&gt;D&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- Set注入 --&gt; &lt;property name=&quot;strSet&quot;&gt; &lt;set&gt; &lt;value&gt;E&lt;/value&gt; &lt;value&gt;F&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- Map注入，两种方式 --&gt; &lt;property name=&quot;strMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;key1&quot; value=&quot;G&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;key2&quot;&gt; &lt;value&gt;H&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- Propert注入，与Map不同，只有一种方式 --&gt; &lt;property name=&quot;props&quot;&gt; &lt;props&gt; &lt;prop key=&quot;key1&quot;&gt;I&lt;/prop&gt; &lt;prop key=&quot;key2&quot;&gt;J&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 简单地打印一下结果： 12345Array: [A, B]List: [C, D]Set: [E, F]Map: {key1=G, key2=H}Properties: {key1=I, key2=J} 我们对xml做一下手脚，将数组、List和Set的标签顺次替换，将Map和Properties的标签交换： 12345678910111213141516171819202122232425262728293031323334&lt;bean id=&quot;exampleClass&quot; class=&quot;org.example.Clazz&quot;&gt; &lt;property name=&quot;strArray&quot;&gt; &lt;set&gt; &lt;value&gt;E&lt;/value&gt; &lt;value&gt;F&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;strList&quot;&gt; &lt;array&gt; &lt;value&gt;A&lt;/value&gt; &lt;value&gt;B&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;strSet&quot;&gt; &lt;list&gt; &lt;value&gt;C&lt;/value&gt; &lt;value&gt;D&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;strMap&quot;&gt; &lt;props&gt; &lt;prop key=&quot;key1&quot;&gt;I&lt;/prop&gt; &lt;prop key=&quot;key2&quot;&gt;J&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=&quot;props&quot;&gt; &lt;map&gt; &lt;entry key=&quot;key1&quot; value=&quot;G&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;key2&quot;&gt; &lt;value&gt;H&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 再打印一下结果： 12345Array: [E, F]List: [A, B]Set: [C, D]Map: {key1=I, key2=J}Properties: {key1=G, key2=H} 非常的amazing啊，注入成功了。这说明了一个问题，对于这些集合类，数组、List和Map是相近的，Map和Properties是相近的，这些相近的集合类之间的标签，是可以等价使用的。 如果集合内部存储的是Bean对象的话，我们可以用&lt;ref&gt;标签来作为代替： 12345678&lt;bean id=&quot;exampleClass&quot; class=&quot;org.example.Clazz&quot;&gt; &lt;property name=&quot;dateArray&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;exampleDate&quot;&gt;&lt;/ref&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;exampleDate&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; Spring中基于注解的IoC容器@Component@Component注解效果等同于xml中的&lt;bean&gt;标签，作用是将被标注的类放进IoC容器中。 123@Component(value = &quot;accountService&quot;)public class AccountServiceImpl implements AccountService {} 经过上述的标注，IoC容器中会创建一个AccountServiceImpl对象，key为accountService。如果不指定value的值，key会默认设为该类的类名，且首字母变为小写，例如上述代码，默认key值为accountServiceImpl。若注解中只有一个属性，且该属性为value，那么可以省去value=。 标注完注解后，需要在xml文件中进行一下配置，告知Spring需要扫描@Component标签。 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;org.example&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; @Controller, @Service和@Repository@Controller, @Service和@Repository这三个注解基本与@Component效果相同。Spring提供这三个标签是为了区分视图层、业务层和持久化层的Bean。其中，@Controller一般用于视图层，@Service一般用于业务层，@Repository一般用于持久化层。 @Scope用于指定Bean的作用范围，效果等同于xml中的&lt;bean&gt;标签的scope属性。@Scope注解拥有一个属性value，取值同&lt;bean&gt;标签的scope属性，常用有’singleton’和’prototype’，用来指定单例和多例。 @PreDestory和@PostConstruct@PreDestory用于指定销毁方法，@PostConstruct用于指定初始化方法。效果分别等同于xml中的&lt;bean&gt;标签的destory-method属性和init-method属性。 注意，上述两个注解在Java 9中已经弃用，若需使用，需要在Maven工程的POM中进行相关的依赖导入。参考来源找不到@PostConstruct和@PreDestroy（原因和解决方法） 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; Spring中基于注解的DI注意，注解DI只能注入基本类型、String和自定义Bean类型，集合类型只能通过XML。 @Autowired@Autowired注解可以标注变量，也可以标注方法。当某个标量被标注上@Autowired时，Spring会根据该变量的变量类型，自动在IoC中寻找对应的Bean来进行注入。注意，因为是自动的，所以需要对应Bean的类型在IoC容器中是唯一的，不能有多个相同类型的Bean。 12345@Component(&quot;accountService&quot;)public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao = null;} 上述代码中，accountDao变量被标注为@Autowired，Spring会在IoC容器中自动查找类型为AccountDao的Bean来进行注入。如果IoC容器中没有此类型的Bean，直接报错；如果有多个此类型的Bean，Spring会根据被注解的变量名称，来寻找IoC容器中是否有对应的key，如果有，就将此key对应的Bean注入。例如上述代码，假设此时IoC容器中有多个类型为AccountDao的Bean，那么Spring会寻找key为accountDao的Bean，若存在，则直接注入；若不存在，则报错。 同基于xml的DI，@Autowired也可注解构造函数和setter。规则同上。 @Qualifier@Qualifier需要与@Autowired配合使用。@Qualifier拥有value属性，可以指定Bean的名称，从而指定注入IoC容器中的哪一个Bean，需要建立在@Autowired注解匹配类型之后，不能独立使用。 123456@Component(&quot;accountService&quot;)public class AccountServiceImpl implements AccountService { @Autowired @Qualifier(&quot;accountDao&quot;) private AccountDao accountDao = null;} @Resource@Autowired和@Qualifier非常笨拙，而且需要配合使用。这时我们可以使用@Resource注解来代替。@Resource拥有一个属性name，用来指定要注入的Bean的id。 12345@Component(&quot;accountService&quot;)public class AccountServiceImpl implements AccountService { @Resource(name = &quot;accountDao&quot;) private AccountDao accountDao = null;} 注：jdk版本过高会导致找不到@Resource标签，需要在Maven工程的POM中加一个额外的依赖。具体方法同“@PreDestory和@PostConstruct”部分。 @Value上述三个注解只能标注Bean类型，对于基本类型和String，需要用到@Value。@Value拥有一个value属性，且支持EL表达式。 完全脱离XML的Spring IoC与DI在上面两个部分，即使我们用了注解，但仍需要在xml文件中配置&lt;context:component-scan&gt;标签。现在我们想用注解去彻底代替掉xml，这时我们需要先创建一个类，名为SpringConfiguration，将它放在config包下。 @Configuration此注解的作用是标识当前被标注的类是一个配置类： 123@Configurationpublic class SpringConfiguration {} @ComponentScan很明显，此注解是用来代替&lt;context:component-scan&gt;标签的，用来告知Spring需扫描哪个包下的@Component注解。他有两个属性value和basePackages，但这两个属性的作用是一样的，选一个即可，用来表示创建容器时需被扫描的包。 1234@Configuration@ComponentScan(basePackages = {&quot;org.example&quot;})public class SpringConfiguration {} 在注解中，如果属性的值为数组，但数组中有且只有一个值，{}其实是可以省略的。 @Bean@Bean注解用来标注在方法上，被@Bean标注的方法需要创建一个特定的Bean对象并返回，这样就可以告知Spring容器，我们需要把这个方法返回值作为Bean对象放进IoC容器中来方便后续的注入。显然，@Bean注解能够用来代替使用factory-bean和factory-method的&lt;bean&gt;标签。 一个很简单的场景，假如我引用了第三方的jar包，比如数据库连接的dbutils，我现在需要里面的QueryRunner对象来进行数据库访问，那么显然，我是无法给QueryRunner这个对象标注上@Component的，因为它存在于第三方的jar包中。此时就需要用到@Bean注解。 我们在SpringConfiguration类中创建一个方法叫做createQueryRunner，这个方法会new一个QueryRunner对象并返回。这时在这个方法上标注上@Bean，就可以告知Spring容器，我们需要把返回的Bean放进IoC容器中。此注解有一个属性name，用来指定这个Bean在IoC容器中的key值。若没有指定name，key的缺省值为当前方法的名称，例如对于下述代码中创建的QueryRunner对象，key为createQueryRunner 12345678910111213141516171819@Bean@Scope(&quot;prototype&quot;)public QueryRunner createQueryRunner(DataSource dataSource) { return new QueryRunner(dataSource);}@Bean(name = &quot;dataSource&quot;)public DataSource createDataSource() { ComboPooledDataSource ds = new ComboPooledDataSource(); try { ds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); ds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/ioc_demo?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&quot;); ds.setUser(&quot;root&quot;); ds.setPassword(&quot;password&quot;); } catch (Exception e) { throw new RuntimeException(e); } return ds;} 如果@Bean标注的方法需要传入参数，Spring框架会在IoC容器中寻找是否有合适的对象，具体规则同@Autowired注释。 AnnotationConfigApplicationContext我们发现，在创建IoC容器的时候，使用的是ClassPathXmlApplicationContext对象，但是这个对象需要去读取xml文件，我们现在又想完全摒弃xml文件。这时就需要用AnnotationConfigApplicationContext。用法如下，需要传入配置类的Class对象： 1ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class); @Import加入我现在有多个配置类，例如我将所有数据库连接相关的全部放入一个名为JdbcConfiguration的类中，这个时候我需要IoC能读取SpringConfiguration和JdbcConfiguration两个配置类的话，有以下几种选择： 将SpringConfiguration和JdbcConfiguration全部标注上@Configuration，并且在SpringConfiguration中的@ComponentScan的属性中加上config包： 1234@Configuration@ComponentScan({&quot;org.example&quot;, &quot;config&quot;})public class SpringConfiguration {} 在创建IoC容器时额外加入JdbcConfiguration的Class对象。此时SpringConfiguration中的@ComponentScan的属性就不再需要加上config包了，并且SpringConfiguration和JdbcConfiguration的@Configuration注解也可以省去： 1ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class, JdbcConfiguration.class); 使用@Import注解。在SpringConfiguration中加入@Import，@Import注解拥有一个value属性，属性值为数组，其中元素为需要引入的其他配置类的Class对象。此时，IoC容器不再需要加入JdbcConfiguration的Class对象，并且SpringConfiguration中的@ComponentScan的属性也不需要加上config包： 12345@Configuration@ComponentScan(&quot;org.example&quot;)@Import(JdbcConfiguration.class)public class SpringConfiguration {} @PropertySource在数据库连接中，我们有一些写死在代码中的信息，例如驱动的选择、数据库url、用户和密码等。我们希望可以随时修改，这就需要额外添加一个配置文件。 现在，在resource文件夹下创建一个properties文件： 1234jdbc-driver=com.mysql.jdbc.Driverjdbc-url=jdbc:mysql://localhost:3306/ioc_demo?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCjdbc-username=rootjdbc-password=password 之后，我们需要给配置类标注上@PropertySource来指定配置文件。@PropertySource拥有一个属性value，表示配置文件的路径。由于配置文件在项目工程的resource目录下，编译后会生成在类路径下，所以需要classpath来指定类路径： 123456@Configuration@ComponentScan(&quot;org.example&quot;)@Import(JdbcConfiguration.class)@PropertySource(&quot;classpath:jdbc-config.properties&quot;)public class SpringConfiguration {} 若需要指定多个配置文件，可以使用@PropertySources注解。 标注@PropertySource后，我们就可以创建一些需要从配置文件中读取的成员变量，并用上文提到的@Value注解来进行注入。 12345678910111213141516171819202122232425262728293031@Configurationpublic class JdbcConfiguration { @Value(&quot;${jdbc-driver}&quot;) private String driver; @Value(&quot;${jdbc-url}&quot;) private String url; @Value(&quot;${jdbc-username}&quot;) private String username; @Value(&quot;${jdbc-password}&quot;) private String password; @Bean @Scope(&quot;prototype&quot;) public QueryRunner queryRunner(DataSource ds) { return new QueryRunner(ds); } @Bean(name = &quot;dataSource&quot;) public DataSource dataSource() { ComboPooledDataSource ds = new ComboPooledDataSource(); try { ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); } catch (Exception e) { throw new RuntimeException(e); } return ds; }}","link":"/2020/07/20/ioc-di/"},{"title":"面向切面编程(AOP)","text":"AOP，Aspect Oriented Programming，也叫面向切片编程，是一种编程范式。网上对于AOP的解释都比较繁琐，简单来讲，AOP能通过代理模式对已有的模块进行增强，动态地将代码切入到某个类的指定位置上的思想就是面向切面的编程。 动态代理动态代理是对代理模式的一种实现。他不同于静态代理，静态代理需要Proxy类和被代理类实现同一接口，采用接口方法覆写的方式实现代理，有些类似于包装器模式。 我们为什么需要代理？假设在当前的业务场景中，业务层某一个方法需要进行多次数据库增删改的操作，这就导致每次使用dao对象对数据库进行操作的时候，都会产生一次数据库连接，这恰恰破坏了数据库事务的原子性：如果中间某个操作异常，程序终止了，但在这异常之前的操作均已提交，导致事务不完整，也无法回滚。正常情况下，我们需要将数据库连接与当前线程绑定，即一个线程一个数据库连接，即使在当前线程中进行了多个数据库操作，这些操作都维持在了一次连接中，若其中某个操作异常，我们仍有余地进行整体的回滚。 下面是手撕的一个用来处理connection的类： 123456789101112131415161718192021222324@Component(&quot;connectionUtils&quot;)public class ConnectionUtils { private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;&gt;(); @Resource(name = &quot;dataSource&quot;) private DataSource dataSource; public Connection getThreadConnection() { Connection conn = tl.get(); try { // whether there has already been a connection in current thread. if (conn == null) { conn = dataSource.getConnection(); tl.set(conn); } return conn; } catch (Exception e) { throw new RuntimeException(e); } } public void removeConnection() { tl.remove(); }} 其中我们使用ThreadLocal来进行数据库连接和线程的绑定。其中提供了两个方法：getThreadConnection方法中，会事先判断当前线程中是否已经拥有连接对象，若没有则创建一个并返回，若有则直接返回；removeConnection负责关闭数据库连接。 处理完连接，下面需要处理数据库的事务控制。一个简易的对事务进行控制的类应该至少拥有开始事务、关闭事务、提交和回滚。下面是一个建议的事务控制类。 1234567891011121314151617181920212223242526272829303132333435363738394041@Component(&quot;transactionManager&quot;)public class TransactionManager { @Resource(name = &quot;connectionUtils&quot;) private ConnectionUtils connUtils; public void beginTransaction() { try { connUtils.getThreadConnection().setAutoCommit(false); } catch (Exception e) { e.printStackTrace(); } } public void commit() { try { connUtils.getThreadConnection().commit(); } catch (Exception e) { e.printStackTrace(); } } public void rollback() { try { connUtils.getThreadConnection().rollback(); } catch (Exception e) { e.printStackTrace(); } } public void release() { try { // 若直接对Connection对象执行close方法的话，jvm只是将这个连接对象放回连接池。 // 所以我们需要使用ConnectionUtils对象中手写的remove方法将其彻底关掉。 connUtils.getThreadConnection().close(); connUtils.removeConnection(); } catch (Exception e) { e.printStackTrace(); } }} 这时我们就算完成了事务和线程的绑定，保证了事务的原子性。在业务层中，我们可以非常建议的使用我们的事务控制类： 123456789101112131415public ReturnValue YourServiceMethod() { ReturnValue returnValue = null; try { tm.beginTransaction(); // Your Service Operations // ... tm.commit(); return returnValue; } catch (Exception e) { tm.rollback(); throw new RuntimeException(e); } finally { tm.release(); }} 可见，我们需要将事务控制的代码将业务逻辑包装起来。但现在有一个问题，我们可能会在一个项目中有很多的业务逻辑，如果给每个业务方法都加上这么一段代码来进行包装的话，会非常的麻烦。而且如果需要对事务控制的代码进行修改的话，业务方法可能也都需要修改，这便造成了代码的不易于维护。这时代理的好处就来了，我们可以实现一个代理类来进行上述事务控制，这样每个业务方法在执行的时候，都会在代理类中的方法中走一遍再继续执行，相当于一个拦截器。Java中主要实现动态代理的方式有两种，JDK代理和cglib代理。 JDK代理JDK代理是采用JDK内置的对象来实现代理。它要求被代理的对象必须至少实现一个接口，否则就无法进行代理。JDK提供的代理类叫做Proxy，我们可以使用其newProxyInstance方法来实现代理。 1static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 这个方法需要三个参数： loader：被代理类的类加载器。可以用 类.getClass().getClassloader()来获取到。 interfaces：被代理类实现的所有接口。可以用 类.getClass().getInterfaces()来获取到。 h：一个InvocationHandler类，直接new一个匿名内部类就可以，其中需要实现一个invoke，类似于回调函数，作用是用来增强被代理的类的方法。 下面是实现的一个建议的用来代理的类，其中实现了一个getAccService方法用来创建能用被代理的AccountSerivce类。 123456789101112131415161718192021222324252627282930313233@Configuration@ComponentScan(&quot;org.example&quot;)public class BeanFactory { @Resource(name = &quot;accountService&quot;) private AccountService accService; @Resource(name = &quot;transactionManager&quot;) private TransactionManager tm; @Bean(name = &quot;proxyAccountService&quot;) public AccountService getAccService() { return (AccountService) Proxy.newProxyInstance(accService.getClass().getClassLoader(), accService.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object returnValue = null; try { tm.beginTransaction(); // operations returnValue = method.invoke(accService, args); tm.commit(); return returnValue; } catch (Exception e) { tm.rollback(); throw new RuntimeException(e); } finally { tm.release(); } } }); }} cglib代理cglib代理是基于子类的动态代理，他不同于JDK内置的代理对象，cglib代理并不需要被代理的类实现接口就可以代理，但需要引入cglib包。 它通过一个Enhancer对象中的create方法来实现代理。create方法相比上述的newProxyInstance方法来说，不需要传递interface作为参数，因为cglib代理并不需要被代理类实现任何接口。对于第三个参数，create方法需要传递一个MethodInterceptor对象，其中需要实现一个intercept方法作为回调函数来进行拦截方法的实现，具体使用与JDK代理类似，下面是使用cglib实现的getAccService()： 123456789101112131415161718192021public AccountService getAccService() { return Enhancer.create(accService.getClass(), new MethodInterceptor() { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { Object returnValue = null; try { tm.beginTransaction(); // operations returnValue = method.invoke(accService, args); tm.commit(); return returnValue; } catch (Exception e) { tm.rollback(); throw new RuntimeException(e); } finally { tm.release(); } } });} AOPAOP思想就如上所述，旨在使用动态代理的方式，对模块进行增强。 在Spring中，同时支持基于接口的动态代理以及基于子类的动态代理。 AOP涉及的一些术语： Joinpoint：连接点。指的就是需要被代理所拦截的地方。在上述例子中，很显然连接点就是业务层中的那些方法。在Spring中只支持方法类型的连接点。 Pointcut：切入点。指的是对于哪些Jointpoint进行拦截。这或许与Joinpoint概念有些混淆。在距离的拦截方法的实现中，我们可以用一些条件语句来对所有Joinpoint，在Spring中也就是方法，进行筛选。我们可以规定那些方法需要被拦截并增强，哪些不需要。而那些需要被拦截的就是Pointcut，所有需要被拦截和不需要被拦截的都是Jointpoint。简单来讲，Joinpoint是指所有可以被拦截的点，而Pointcut是实际需要被拦截的点，Joinpoint包含Pointcut，所有Pointcut一定是Joinpoint，但Joinpoint不一定是Pointcut。 Advice：通知，也就是具体的增强实现，简单来讲就是拦截后对连接点需要做的事情。具体分为before advice，after advice，after-returning advice，after-throwing advice和around advice。这个很好理解，用上面的JDK代理中的invoke方法做个例子： 1234567891011121314151617@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object returnValue = null; try { tm.beginTransaction(); // before // operations returnValue = method.invoke(accService, args); tm.commit(); // after-returning return returnValue; } catch (Exception e) { // after-throwing tm.rollback(); throw new RuntimeException(e); } finally { // after tm.release(); }} 在具体操作之前的都是before advice，之后的都是after-returning advice，catch中异常抛出部分的都是after-throwing，finally中最后执行的都是after，而整个invoke方法，就是一个around advice。所以。在around advice中，需要有明确的Pointcut方法调用。 Introduction：引介。是一种特殊的advice，在不修改类代码的前提下，引介可以在运行时为类动态添加方法或者Field。 Target：被代理的目标对象。 Weaving：织入。把增强的部分应用到目标对象来创建新的被代理的对象的过程。 Proxy：代理。Target被织入增强后，会产生一个被代理的结果类。在上述代码中，我们直接return了被代理的AccountService类。 Aspect：切面。Pointcut和Advice的结合，也就是说，是被增强的方法和如何增强的方法两者的结合。 Spring中基于XML的AOP为了方便演示，我们预先创建一个Logger类用来模拟打印日志，其中提供四个方法，分别对应除了around advice之外的四种advice。 1234567891011121314151617public class Logger { public void beforeLog() { System.out.println(&quot;Before logging...&quot;); } public void afterLog() { System.out.println(&quot;After logging...&quot;); } public void afterReturningLog() { System.out.println(&quot;After-returning logging...&quot;); } public void afterThrowingLog() { System.out.println(&quot;After-throwing logging...&quot;); }} 我们希望printLog函数在每个业务方法执行之前执行，也就是说，我们希望printLog方法作为一个before advice。 下面，在bean.xml中进行相关配置。首先根据Spring官方文档来引入&lt;bean&gt;标签，并配置Service类来把需要被代理的类放进IoC容器中，当然，使用注解也是可以的： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;bean id=&quot;accountService&quot; class=&quot;org.example.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 配置Advice类首先需要把Advice类放进IoC容器中，具体方法和配置普通Bean一样： 1&lt;bean id=&quot;logger&quot; class=&quot;org.example.utils.Logger&quot;&gt;&lt;/bean&gt; &lt;aop:config&gt;使用&lt;aop:config&gt;标签来表明这时AOP配置的开始： 1234&lt;bean id=&quot;logger&quot; class=&quot;org.example.utils.Logger&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt;&lt;/aop:config&gt; &lt;aop:aspect&gt;在&lt;aop:config&gt;标签来内使用&lt;aop:aspect&gt;标签来标注切面的配置。其中有两个属性： id：给切面一个唯一的标识。 ref：指定Advice类bean的id。 1234&lt;bean id=&quot;logger&quot; class=&quot;org.example.utils.Logger&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;&lt;/aop:aspect&gt;&lt;/aop:config&gt; 配置Advice类型和切入点在&lt;aop:aspect&gt;标签来内使用额外标签来配置Advice类型： &lt;aop:before&gt;：before advice &lt;aop:after&gt;：after advice &lt;aop:after-returning&gt;：after-returning advice &lt;aop:after-throwing&gt;：after-throwing advice &lt;aop:around&gt;：around advice 其中他们都有两个属性： method：指定Advice类中的具体方法。 pointcut：指定切入点位置。需要特定的切入表达式，表达式具体形式为： 1访问修饰符 返回值 包名.类名.方法值(参数列表) 上述表达式，需要放在execution()的括号内部。例如，我要在AccountServiceImpl中的saveAccount方法之前进行printLog的切入，具体xml配置如下： 1234567&lt;bean id=&quot;'accountService&quot; class=&quot;org.example.service.impl.AccountServiceImpl&quot;/&gt;&lt;bean id=&quot;logger&quot; class=&quot;org.example.utils.Logger&quot;/&gt;&lt;aop:config&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;aop:before method=&quot;beforeLog&quot; pointcut=&quot;execution(public void org.example.service.impl.AccountServiceImpl.saveAccount())&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 对于除了around advice之外的剩下三种advice，具体配置方法都是同样的。关于around advice，会在后文讲到。 使用切入表达式需要引入aspectj的相关jar包，具体maven坐标为： 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt;&lt;/dependency&gt; 全通配表达式上述的访问修饰符 返回值 包名.类名.方法值(参数列表)是标准的切入表达式写法，但太过于繁琐，若我需要同时切入多个业务层方法，每个方法都得写一个这玩意，太麻烦，所以我们还有一些简易的写法。 全通配表达式的具体形式为* *..*.*(..)，这些乱起八糟的星号的点不需要有任何替换，直接放进execution()内就可使用： 12345&lt;aop:config&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;aop:before method=&quot;beforeLog&quot; pointcut=&quot;execution(* *..*.*(..))&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 非常的amazing啊，而且测试一下还会发现，业务层里的所有方法都被切入了。 具体原理如下： 访问修饰符可以省略。 使用通配符来表示任意的返回值，也就是第一个*。 包名也可以用通配符*表示，其中，有几级包，就用几个*.代替。例如上述org.example.service.impl.AccountServiceImpl.saveAccount()，有四级包，就需要用* *.*.*.*.AccountServiceImpl.saveAccount()来表示。此外，还可以用..来代替当前包以下的所有包，例如，用* *.*.AccountServiceImpl.saveAccount()来表示``org.example下的所有包，只要里面有AccountServiceImpl.saveAccount()，就可以切入增强。所以，我们可以用* *..AccountServiceImpl.saveAccount()`来进行全通配。 类名和方法名也可以用通配符。例如* *..*.*()，但此时只能切入所有不需要参数的方法，需要传参的方法仍需要在括号中指定参数的类型，其中，基本类型直接写名称，引用类型需使用”包名.类名“。 参数名也可以使用全通配符*，即* *..*.*(*)，但这表示切入点方法必须要有参数，不能切入没有参数的方法。若要实现全通配，需要用..来表示任意参数，包括有参数和无参数，即* *..*.*(..)。 若使用全通配，整个项目中的所有方法都会被切入，在实际开发中，一般只切入到业务层实现类下的所有方法，具体表达式大致为* org.example.service.impl.*.*(..)。 &lt;aop:pointcut&gt;&lt;aop:pointcut&gt;是一个用来表示通用切入点表达式的标签。例如在Logger类中，我们有多个方法需要以不同advice类型来进行切入，切入位置都是一样的，那么写好几个重复的切入表达式未免有些繁琐，我们就可以用&lt;aop:pointcut&gt;来表示一个通用的切入表达式，并在每个advice所对应的标签内使用pointcut-ref属性来进行指定： 12345678910&lt;aop:config&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;aop:before method=&quot;beforeLog&quot; pointcut-ref=&quot;servicePointcut&quot;/&gt; &lt;aop:after-returning method=&quot;afterReturningLog&quot; pointcut-ref=&quot;servicePointcut&quot;/&gt; &lt;aop:after-throwing method=&quot;afterThrowingLog&quot; pointcut-ref=&quot;servicePointcut&quot;/&gt; &lt;aop:after method=&quot;afterLog&quot; pointcut-ref=&quot;servicePointcut&quot;/&gt; &lt;aop:pointcut id=&quot;servicePointcut&quot; expression=&quot;execution(* org.example.service.impl.*.*(..))&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 此时上述&lt;aop:pointcut&gt;只作用于当前&lt;aop:aspect&gt;表示的切面内，若要通用与所有切面，需放在&lt;aop:aspect&gt;之外&lt;aop:config&gt;内，且必须置于&lt;aop:aspect&gt;标签之前。 Around Advice切入Around advice与其他类型的advice不同的地方就在于我们需要让切入点方法处于around advice中被调用，若我们什么都不做的话，单纯按照其他advice的切入方法进行配置的话，会发现around advice执行了，但切入点的方法不会执行。 为了想办法明确切入点方法在around advice中被调用，需要用到Spring提供的ProceedingJoinPoint接口。此接口有一个方法proceed，这个方法能够明确调用切入点方法。我们要做的，就是把这个接口作为参数传入around advice中，在执行时，Spring会自动提供该接口的实现。 例如，我们在Logger中添加一个around advice方法： 123456789101112131415public Object aroundLog(ProceedingJoinPoint pjp) { Object rtValue = null; try { System.out.println(&quot;Before in around advice...&quot;); Object[] args = pjp.getArgs(); // 获取方法所需的参数列表 rtValue = pjp.proceed(args); // 明确切入点方法 System.out.println(&quot;After-returning in around advice...&quot;); return rtValue; } catch (Throwable t) { System.out.println(&quot;After-throwing in around advice...&quot;); throw new RuntimeException(t); } finally { System.out.println(&quot;After in around advice...&quot;); }} 可以看到，我们使用ProceedingJoinPoint的getArgs方法来获取参数，并传入proceed方法来进行切入点方法调用。 值得一提的是，上面这个方法与一开始我们手撕的动态代理的代码基本一样。我在这个方法中写了四个打印函数，这四个打印函数，恰恰分别代表了另外四种advice。也就是说，在Spring中，around advice就是一种可以在代码中手动控制增强方法何时执行的方式。 Spring中基于注解的AOP首先，自然需要先给需要通过AOP代理的切面类注上@Component来告诉Spring需要把这个类放入IoC容器中。 &lt;aop:aspectj-autoproxy&gt;我们首先需要在bean.xml中加上这个标签，来表示在项目中我们使用注解来进行AOP。 12&lt;context:component-scan base-package=&quot;org.example&quot;/&gt;&lt;aop:aspectj-autoproxy/&gt; @EnableAspectJAutoProxy想要完全脱离xml，我们可以用@EnableAspectJAutoProxy来代替&lt;aop:aspectj-autoproxy&gt;。需要将此注解标注在配置类上： 12345@Configuration@ComponentScan(&quot;org.example&quot;)@EnableAspectJAutoProxypublic class SpringConfiguration {} @Aspect所有切面类需要用@Aspect来进行标注，以此来代替&lt;aop:aspect&gt;。 1234@Component(&quot;logger&quot;)@Aspectpublic class Logger {} @Pointcut此注解是用来代替&lt;aop:pointcut&gt;标签的。其需要指定一个切入表达式，并标注在一个方法上，该方法内可以什么都不写： 12@Pointcut(&quot;execution(* org.example.service.impl.*.*(..))&quot;)private void pointCut() {} @Before, @After, @AfterReturing, @AfterThrowing和@Around很显然，这几个注解是用来分别标注五种不同类型的advice的。需要注意的是，Junit也有@Before和@After这两个注解，选择的时候记得看包名。 同时，这些注解需要指定一个被@Pointcut标注的方法，注意，方法需要带上括号： 123456789101112131415161718192021222324252627282930313233343536@Before(&quot;pointCut()&quot;)public void beforeLog() { System.out.println(&quot;Before logging...&quot;);}@After(&quot;pointCut()&quot;)public void afterLog() { System.out.println(&quot;After logging...&quot;);}@AfterReturning(&quot;pointCut()&quot;)public void afterReturningLog() { System.out.println(&quot;After-returning logging...&quot;);}@AfterThrowing(&quot;pointCut()&quot;)public void afterThrowingLog() { System.out.println(&quot;After-throwing logging...&quot;);}@Around(&quot;pointCut()&quot;)public Object aroundLog(ProceedingJoinPoint pjp) { Object rtValue = null; try { System.out.println(&quot;Before in around advice...&quot;); Object[] args = pjp.getArgs(); // 获取方法所需的参数列表 rtValue = pjp.proceed(args); // 明确切入点方法 System.out.println(&quot;After-returning in around advice...&quot;); return rtValue; } catch (Throwable t) { System.out.println(&quot;After-throwing in around advice...&quot;); throw new RuntimeException(t); } finally { System.out.println(&quot;After in around advice...&quot;); }} 注，在一些旧版本的Spring中，使用注解AOP后无法保证每个advice的执行顺序。例如，after也有可能在after-returning之前执行。对于around advice无此问题。5.2.7版本已经修复了这个问题。","link":"/2020/08/10/aop/"}],"tags":[{"name":"scipy","slug":"scipy","link":"/tags/scipy/"},{"name":"optimization","slug":"optimization","link":"/tags/optimization/"},{"name":"machine learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"transfer learning","slug":"transfer-learning","link":"/tags/transfer-learning/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"data structure","slug":"data-structure","link":"/tags/data-structure/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"}],"categories":[{"name":"machine learning","slug":"machine-learning","link":"/categories/machine-learning/"},{"name":"coding","slug":"coding","link":"/categories/coding/"},{"name":"algorithms","slug":"algorithms","link":"/categories/algorithms/"}]}