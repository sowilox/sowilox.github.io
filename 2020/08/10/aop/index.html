<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>面向切面编程(AOP) - Core Dump</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Core Dump"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Core Dump"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="AOP，Aspect Oriented Programming，也叫面向切片编程，是一种编程范式。网上对于AOP的解释都比较繁琐，简单来讲，AOP能通过代理模式对已有的模块进行增强，动态地将代码切入到某个类的指定位置上的思想就是面向切面的编程。"><meta property="og:type" content="blog"><meta property="og:title" content="面向切面编程(AOP)"><meta property="og:url" content="http://xnsi.github.io/2020/08/10/aop/"><meta property="og:site_name" content="Core Dump"><meta property="og:description" content="AOP，Aspect Oriented Programming，也叫面向切片编程，是一种编程范式。网上对于AOP的解释都比较繁琐，简单来讲，AOP能通过代理模式对已有的模块进行增强，动态地将代码切入到某个类的指定位置上的思想就是面向切面的编程。"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://xnsi.github.io/img/og_image.png"><meta property="article:published_time" content="2020-08-10T09:32:26.000Z"><meta property="article:modified_time" content="2021-11-19T13:54:46.434Z"><meta property="article:author" content="s.x."><meta property="article:tag" content="Java"><meta property="article:tag" content="Spring"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://xnsi.github.io/2020/08/10/aop/"},"headline":"面向切面编程(AOP)","image":["http://xnsi.github.io/img/og_image.png"],"datePublished":"2020-08-10T09:32:26.000Z","dateModified":"2021-11-19T13:54:46.434Z","author":{"@type":"Person","name":"s.x."},"publisher":{"@type":"Organization","name":"Core Dump","logo":{"@type":"ImageObject","url":"http://xnsi.github.io/img/logo.jpg"}},"description":"AOP，Aspect Oriented Programming，也叫面向切片编程，是一种编程范式。网上对于AOP的解释都比较繁琐，简单来讲，AOP能通过代理模式对已有的模块进行增强，动态地将代码切入到某个类的指定位置上的思想就是面向切面的编程。"}</script><link rel="canonical" href="http://xnsi.github.io/2020/08/10/aop/"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-175447554-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-175447554-1');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><meta name="generator" content="Hexo 6.0.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.jpg" alt="Core Dump" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xnsi/xnsi.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-08-10T09:32:26.000Z" title="2020-8-10 5:32:26 ├F10: AM┤">2020-08-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-19T13:54:46.434Z" title="2021-11-19 8:54:46 ├F10: AM┤">2021-11-19</time></span><span class="level-item"><a class="link-muted" href="/categories/coding/">coding</a></span><span class="level-item">30 minutes read (About 4561 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">面向切面编程(AOP)</h1><div class="content"><p>AOP，Aspect Oriented Programming，也叫面向切片编程，是一种编程范式。网上对于AOP的解释都比较繁琐，简单来讲，AOP能通过代理模式对已有的模块进行增强，动态地将代码切入到某个类的指定位置上的思想就是面向切面的编程。<span id="more"></span></p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>动态代理是对代理模式的一种实现。他不同于静态代理，静态代理需要Proxy类和被代理类实现同一接口，采用接口方法覆写的方式实现代理，有些类似于包装器模式。</p>
<p>我们为什么需要代理？假设在当前的业务场景中，业务层某一个方法需要进行多次数据库增删改的操作，这就导致每次使用dao对象对数据库进行操作的时候，都会产生一次数据库连接，这恰恰破坏了数据库事务的原子性：如果中间某个操作异常，程序终止了，但在这异常之前的操作均已提交，导致事务不完整，也无法回滚。正常情况下，我们需要将数据库连接与当前线程绑定，即一个线程一个数据库连接，即使在当前线程中进行了多个数据库操作，这些操作都维持在了一次连接中，若其中某个操作异常，我们仍有余地进行整体的回滚。</p>
<p>下面是手撕的一个用来处理connection的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;connectionUtils&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="meta">@Resource(name = &quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getThreadConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn = tl.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// whether there has already been a connection in current thread.</span></span><br><span class="line">            <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn = dataSource.getConnection();</span><br><span class="line">                tl.set(conn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中我们使用<code>ThreadLocal</code>来进行数据库连接和线程的绑定。其中提供了两个方法：<code>getThreadConnection</code>方法中，会事先判断当前线程中是否已经拥有连接对象，若没有则创建一个并返回，若有则直接返回；<code>removeConnection</code>负责关闭数据库连接。</p>
<p>处理完连接，下面需要处理数据库的事务控制。一个简易的对事务进行控制的类应该至少拥有开始事务、关闭事务、提交和回滚。下面是一个建议的事务控制类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;transactionManager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;connectionUtils&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connUtils;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connUtils.getThreadConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connUtils.getThreadConnection().commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connUtils.getThreadConnection().rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 若直接对Connection对象执行close方法的话，jvm只是将这个连接对象放回连接池。</span></span><br><span class="line">            <span class="comment">// 所以我们需要使用ConnectionUtils对象中手写的remove方法将其彻底关掉。</span></span><br><span class="line">            connUtils.getThreadConnection().close();</span><br><span class="line">            connUtils.removeConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时我们就算完成了事务和线程的绑定，保证了事务的原子性。在业务层中，我们可以非常建议的使用我们的事务控制类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ReturnValue <span class="title">YourServiceMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReturnValue returnValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        tm.beginTransaction();</span><br><span class="line">        <span class="comment">// Your Service Operations</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        tm.commit();</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        tm.rollback();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        tm.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，我们需要将事务控制的代码将业务逻辑包装起来。但现在有一个问题，我们可能会在一个项目中有很多的业务逻辑，如果给每个业务方法都加上这么一段代码来进行包装的话，会非常的麻烦。而且如果需要对事务控制的代码进行修改的话，业务方法可能也都需要修改，这便造成了代码的不易于维护。这时代理的好处就来了，我们可以实现一个代理类来进行上述事务控制，这样每个业务方法在执行的时候，都会在代理类中的方法中走一遍再继续执行，相当于一个拦截器。Java中主要实现动态代理的方式有两种，JDK代理和cglib代理。</p>
<h2 id="JDK代理"><a href="#JDK代理" class="headerlink" title="JDK代理"></a>JDK代理</h2><p>JDK代理是采用JDK内置的对象来实现代理。它要求被代理的对象必须至少实现一个接口，否则就无法进行代理。JDK提供的代理类叫做<code>Proxy</code>，我们可以使用其<code>newProxyInstance</code>方法来实现代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object	<span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>

<p>这个方法需要三个参数：</p>
<ul>
<li>loader：被代理类的类加载器。可以用<code> 类.getClass().getClassloader()</code>来获取到。</li>
<li>interfaces：被代理类实现的所有接口。可以用<code> 类.getClass().getInterfaces()</code>来获取到。</li>
<li>h：一个<code>InvocationHandler</code>类，直接new一个匿名内部类就可以，其中需要实现一个<code>invoke</code>，类似于回调函数，作用是用来增强被代理的类的方法。</li>
</ul>
<p>下面是实现的一个建议的用来代理的类，其中实现了一个<code>getAccService</code>方法用来创建能用被代理的<code>AccountSerivce</code>类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;org.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;accountService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accService;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;transactionManager&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> TransactionManager tm;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;proxyAccountService&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountService <span class="title">getAccService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (AccountService) Proxy.newProxyInstance(accService.getClass().getClassLoader(),</span><br><span class="line">                accService.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            tm.beginTransaction();</span><br><span class="line">                            <span class="comment">// operations</span></span><br><span class="line">                            returnValue = method.invoke(accService, args);</span><br><span class="line"></span><br><span class="line">                            tm.commit();</span><br><span class="line">                            <span class="keyword">return</span> returnValue;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            tm.rollback();</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            tm.release();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="cglib代理"><a href="#cglib代理" class="headerlink" title="cglib代理"></a>cglib代理</h2><p>cglib代理是基于子类的动态代理，他不同于JDK内置的代理对象，cglib代理并不需要被代理的类实现接口就可以代理，但需要引入cglib包。</p>
<p>它通过一个<code>Enhancer</code>对象中的<code>create</code>方法来实现代理。<code>create</code>方法相比上述的<code>newProxyInstance</code>方法来说，不需要传递interface作为参数，因为cglib代理并不需要被代理类实现任何接口。对于第三个参数，<code>create</code>方法需要传递一个<code>MethodInterceptor</code>对象，其中需要实现一个<code>intercept</code>方法作为回调函数来进行拦截方法的实现，具体使用与JDK代理类似，下面是使用cglib实现的<code>getAccService()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AccountService <span class="title">getAccService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enhancer.create(accService.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    tm.beginTransaction();</span><br><span class="line">                    <span class="comment">// operations</span></span><br><span class="line">                    returnValue = method.invoke(accService, args);</span><br><span class="line"></span><br><span class="line">                    tm.commit();</span><br><span class="line">                    <span class="keyword">return</span> returnValue;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    tm.rollback();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    tm.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP思想就如上所述，旨在使用动态代理的方式，对模块进行增强。</p>
<p>在Spring中，同时支持基于接口的动态代理以及基于子类的动态代理。</p>
<p>AOP涉及的一些术语：</p>
<ul>
<li><p>Joinpoint：连接点。指的就是需要被代理所拦截的地方。在上述例子中，很显然连接点就是业务层中的那些方法。在Spring中只支持方法类型的连接点。</p>
</li>
<li><p>Pointcut：切入点。指的是对于哪些Jointpoint进行拦截。这或许与Joinpoint概念有些混淆。在距离的拦截方法的实现中，我们可以用一些条件语句来对所有Joinpoint，在Spring中也就是方法，进行筛选。我们可以规定那些方法需要被拦截并增强，哪些不需要。而那些需要被拦截的就是Pointcut，所有需要被拦截和不需要被拦截的都是Jointpoint。简单来讲，Joinpoint是指所有可以被拦截的点，而Pointcut是实际需要被拦截的点，Joinpoint包含Pointcut，所有Pointcut一定是Joinpoint，但Joinpoint不一定是Pointcut。</p>
</li>
<li><p>Advice：通知，也就是具体的增强实现，简单来讲就是拦截后对连接点需要做的事情。具体分为before advice，after advice，after-returning advice，after-throwing advice和around advice。这个很好理解，用上面的JDK代理中的<code>invoke</code>方法做个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        tm.beginTransaction();	<span class="comment">// before</span></span><br><span class="line">        <span class="comment">// operations</span></span><br><span class="line">        returnValue = method.invoke(accService, args);</span><br><span class="line"></span><br><span class="line">        tm.commit();			<span class="comment">// after-returning</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;		<span class="comment">// after-throwing</span></span><br><span class="line">        tm.rollback();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;					<span class="comment">// after</span></span><br><span class="line">        tm.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在具体操作之前的都是before advice，之后的都是after-returning advice，catch中异常抛出部分的都是after-throwing，finally中最后执行的都是after，而整个invoke方法，就是一个around advice。所以。在around advice中，需要有明确的Pointcut方法调用。</p>
</li>
<li><p>Introduction：引介。是一种特殊的advice，在不修改类代码的前提下，引介可以在运行时为类动态添加方法或者Field。</p>
</li>
<li><p>Target：被代理的目标对象。</p>
</li>
<li><p>Weaving：织入。把增强的部分应用到目标对象来创建新的被代理的对象的过程。</p>
</li>
<li><p>Proxy：代理。Target被织入增强后，会产生一个被代理的结果类。在上述代码中，我们直接return了被代理的<code>AccountService</code>类。</p>
</li>
<li><p>Aspect：切面。Pointcut和Advice的结合，也就是说，是被增强的方法和如何增强的方法两者的结合。</p>
</li>
</ul>
<h1 id="Spring中基于XML的AOP"><a href="#Spring中基于XML的AOP" class="headerlink" title="Spring中基于XML的AOP"></a>Spring中基于XML的AOP</h1><p>为了方便演示，我们预先创建一个<code>Logger</code>类用来模拟打印日志，其中提供四个方法，分别对应除了around advice之外的四种advice。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before logging...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After logging...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After-returning logging...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After-throwing logging...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望<code>printLog</code>函数在每个业务方法执行之前执行，也就是说，我们希望<code>printLog</code>方法作为一个before advice。</p>
<p>下面，在bean.xml中进行相关配置。首先根据<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#spring-core">Spring官方文档</a>来引入<code>&lt;bean&gt;标签</code>，并配置Service类来把需要被代理的类放进IoC容器中，当然，使用注解也是可以的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.service.impl.AccountServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置Advice类"><a href="#配置Advice类" class="headerlink" title="配置Advice类"></a>配置Advice类</h2><p>首先需要把Advice类放进IoC容器中，具体方法和配置普通Bean一样：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logger&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.utils.Logger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="lt-aop-config-gt"><a href="#lt-aop-config-gt" class="headerlink" title="&lt;aop:config&gt;"></a>&lt;aop:config&gt;</h2><p>使用<code>&lt;aop:config&gt;</code>标签来表明这时AOP配置的开始：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logger&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.utils.Logger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="lt-aop-aspect-gt"><a href="#lt-aop-aspect-gt" class="headerlink" title="&lt;aop:aspect&gt;"></a>&lt;aop:aspect&gt;</h2><p>在<code>&lt;aop:config&gt;</code>标签来内使用<code>&lt;aop:aspect&gt;</code>标签来标注切面的配置。其中有两个属性：</p>
<ul>
<li><p>id：给切面一个唯一的标识。</p>
</li>
<li><p>ref：指定Advice类bean的id。</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logger&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.utils.Logger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置Advice类型和切入点"><a href="#配置Advice类型和切入点" class="headerlink" title="配置Advice类型和切入点"></a>配置Advice类型和切入点</h2><p>在<code>&lt;aop:aspect&gt;</code>标签来内使用额外标签来配置Advice类型：</p>
<ul>
<li><code>&lt;aop:before&gt;</code>：before advice</li>
<li><code>&lt;aop:after&gt;</code>：after advice</li>
<li><code>&lt;aop:after-returning&gt;</code>：after-returning advice</li>
<li><code>&lt;aop:after-throwing&gt;</code>：after-throwing advice</li>
<li><code>&lt;aop:around&gt;</code>：around advice</li>
</ul>
<p>其中他们都有两个属性：</p>
<ul>
<li><p>method：指定Advice类中的具体方法。</p>
</li>
<li><p>pointcut：指定切入点位置。需要特定的切入表达式，表达式具体形式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 返回值 包名.类名.方法值(参数列表)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上述表达式，需要放在<code>execution()</code>的括号内部。例如，我要在<code>AccountServiceImpl</code>中的<code>saveAccount</code>方法之前进行<code>printLog</code>的切入，具体xml配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&#x27;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.service.impl.AccountServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logger&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.utils.Logger&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logger&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforeLog&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public void org.example.service.impl.AccountServiceImpl.saveAccount())&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于除了around advice之外的剩下三种advice，具体配置方法都是同样的。关于around advice，会在后文讲到。</p>
<p>使用切入表达式需要引入aspectj的相关jar包，具体maven坐标为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="全通配表达式"><a href="#全通配表达式" class="headerlink" title="全通配表达式"></a>全通配表达式</h2><p>上述的<code>访问修饰符 返回值 包名.类名.方法值(参数列表)</code>是标准的切入表达式写法，但太过于繁琐，若我需要同时切入多个业务层方法，每个方法都得写一个这玩意，太麻烦，所以我们还有一些简易的写法。</p>
<p>全通配表达式的具体形式为<code>* *..*.*(..)</code>，这些乱起八糟的星号的点不需要有任何替换，直接放进<code>execution()</code>内就可使用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logger&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforeLog&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>非常的amazing啊，而且测试一下还会发现，业务层里的所有方法都被切入了。</p>
<p>具体原理如下：</p>
<ol>
<li><p>访问修饰符可以省略。</p>
</li>
<li><p>使用通配符来表示任意的返回值，也就是第一个<code>*</code>。</p>
</li>
<li><p>包名也可以用通配符<code>*</code>表示，其中，有几级包，就用几个<code>*.</code>代替。例如上述<code>org.example.service.impl.AccountServiceImpl.saveAccount()</code>，有四级包，就需要用<code>* *.*.*.*.AccountServiceImpl.saveAccount()</code>来表示。此外，还可以用<code>..</code>来代替当前包以下的所有包，例如，用<code>* *.*.AccountServiceImpl.saveAccount()</code>来表示``org.example<code>下的所有包，只要里面有</code>AccountServiceImpl.saveAccount()<code>，就可以切入增强。所以，我们可以用</code>* *..AccountServiceImpl.saveAccount()`来进行全通配。</p>
</li>
<li><p>类名和方法名也可以用通配符。例如<code>* *..*.*()</code>，但此时只能切入所有不需要参数的方法，需要传参的方法仍需要在括号中指定参数的类型，其中，基本类型直接写名称，引用类型需使用”包名.类名“。</p>
</li>
<li><p>参数名也可以使用全通配符<code>*</code>，即<code>* *..*.*(*)</code>，但这表示切入点方法必须要有参数，不能切入没有参数的方法。若要实现全通配，需要用<code>..</code>来表示任意参数，包括有参数和无参数，即<code>* *..*.*(..)</code>。</p>
</li>
</ol>
<p>若使用全通配，整个项目中的所有方法都会被切入，在实际开发中，一般只切入到业务层实现类下的所有方法，具体表达式大致为<code>* org.example.service.impl.*.*(..)</code>。</p>
<h2 id="lt-aop-pointcut-gt"><a href="#lt-aop-pointcut-gt" class="headerlink" title="&lt;aop:pointcut&gt;"></a>&lt;aop:pointcut&gt;</h2><p><code>&lt;aop:pointcut&gt;</code>是一个用来表示通用切入点表达式的标签。例如在<code>Logger</code>类中，我们有多个方法需要以不同advice类型来进行切入，切入位置都是一样的，那么写好几个重复的切入表达式未免有些繁琐，我们就可以用<code>&lt;aop:pointcut&gt;</code>来表示一个通用的切入表达式，并在每个advice所对应的标签内使用<code>pointcut-ref</code>属性来进行指定：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logger&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforeLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;servicePointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturningLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;servicePointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowingLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;servicePointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;servicePointcut&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;servicePointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* org.example.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时上述<code>&lt;aop:pointcut&gt;</code>只作用于当前<code>&lt;aop:aspect&gt;</code>表示的切面内，若要通用与所有切面，需放在<code>&lt;aop:aspect&gt;</code>之外<code>&lt;aop:config&gt;</code>内，且必须置于<code>&lt;aop:aspect&gt;</code>标签之前。</p>
<h2 id="Around-Advice切入"><a href="#Around-Advice切入" class="headerlink" title="Around Advice切入"></a>Around Advice切入</h2><p>Around advice与其他类型的advice不同的地方就在于我们需要让切入点方法处于around advice中被调用，若我们什么都不做的话，单纯按照其他advice的切入方法进行配置的话，会发现around advice执行了，但切入点的方法不会执行。</p>
<p>为了想办法明确切入点方法在around advice中被调用，需要用到Spring提供的<code>ProceedingJoinPoint</code>接口。此接口有一个方法<code>proceed</code>，这个方法能够明确调用切入点方法。我们要做的，就是把这个接口作为参数传入around advice中，在执行时，Spring会自动提供该接口的实现。</p>
<p>例如，我们在<code>Logger</code>中添加一个around advice方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundLog</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">    Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before in around advice...&quot;</span>);</span><br><span class="line">        Object[] args = pjp.getArgs(); <span class="comment">// 获取方法所需的参数列表</span></span><br><span class="line">        rtValue = pjp.proceed(args); <span class="comment">// 明确切入点方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After-returning in around advice...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rtValue;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After-throwing in around advice...&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After in around advice...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们使用<code>ProceedingJoinPoint</code>的<code>getArgs</code>方法来获取参数，并传入<code>proceed</code>方法来进行切入点方法调用。</p>
<p>值得一提的是，上面这个方法与一开始我们手撕的动态代理的代码基本一样。我在这个方法中写了四个打印函数，这四个打印函数，恰恰分别代表了另外四种advice。也就是说，在Spring中，around advice就是一种可以在代码中手动控制增强方法何时执行的方式。</p>
<h1 id="Spring中基于注解的AOP"><a href="#Spring中基于注解的AOP" class="headerlink" title="Spring中基于注解的AOP"></a>Spring中基于注解的AOP</h1><p>首先，自然需要先给需要通过AOP代理的切面类注上<code>@Component</code>来告诉Spring需要把这个类放入IoC容器中。</p>
<h2 id="lt-aop-aspectj-autoproxy-gt"><a href="#lt-aop-aspectj-autoproxy-gt" class="headerlink" title="&lt;aop:aspectj-autoproxy&gt;"></a>&lt;aop:aspectj-autoproxy&gt;</h2><p>我们首先需要在bean.xml中加上这个标签，来表示在项目中我们使用注解来进行AOP。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h2><p>想要完全脱离xml，我们可以用<code>@EnableAspectJAutoProxy</code>来代替<code>&lt;aop:aspectj-autoproxy&gt;</code>。需要将此注解标注在配置类上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;org.example&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h2><p>所有切面类需要用<code>@Aspect</code>来进行标注，以此来代替<code>&lt;aop:aspect&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;logger&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pointcut"><a href="#Pointcut" class="headerlink" title="@Pointcut"></a>@Pointcut</h2><p>此注解是用来代替<code>&lt;aop:pointcut&gt;</code>标签的。其需要指定一个切入表达式，并标注在一个方法上，该方法内可以什么都不写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* org.example.service.impl.*.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Before-After-AfterReturing-AfterThrowing和-Around"><a href="#Before-After-AfterReturing-AfterThrowing和-Around" class="headerlink" title="@Before, @After, @AfterReturing, @AfterThrowing和@Around"></a>@Before, @After, @AfterReturing, @AfterThrowing和@Around</h2><p>很显然，这几个注解是用来分别标注五种不同类型的advice的。需要注意的是，Junit也有<code>@Before</code>和<code>@After</code>这两个注解，选择的时候记得看包名。</p>
<p>同时，这些注解需要指定一个被<code>@Pointcut</code>标注的方法，注意，方法需要带上括号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Before logging...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;After logging...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterReturning(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;After-returning logging...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterThrowing(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;After-throwing logging...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundLog</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">    Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before in around advice...&quot;</span>);</span><br><span class="line">        Object[] args = pjp.getArgs(); <span class="comment">// 获取方法所需的参数列表</span></span><br><span class="line">        rtValue = pjp.proceed(args); <span class="comment">// 明确切入点方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After-returning in around advice...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rtValue;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After-throwing in around advice...&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After in around advice...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注，在一些旧版本的Spring中，使用注解AOP后无法保证每个advice的执行顺序。例如，after也有可能在after-returning之前执行。对于around advice无此问题。5.2.7版本已经修复了这个问题。</p>
</blockquote>
</div><div class="article-licensing box"><div class="licensing-title"><p>面向切面编程(AOP)</p><p><a href="http://xnsi.github.io/2020/08/10/aop/">http://xnsi.github.io/2020/08/10/aop/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>s.x.</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-08-10</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-11-19</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a><a class="link-muted mr-2" rel="tag" href="/tags/Spring/">Spring</a></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f36627a4fb687b2" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" href="https://www.buymeacoffee.com/sowilo" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/09/12/index-and-b+tree/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">索引与B+树</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/07/20/ioc-di/"><span class="level-item">控制反转和依赖注入</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "63a2eb6d172d25298c47692e018bed7f",
            repo: "xnsi.github.io",
            owner: "xnsi",
            clientID: "d90c20361b6ee51f6978",
            clientSecret: "ef837ebe52553ef06028b18bab69182ed9e64fcf",
            admin: ["xnsi"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#动态代理"><span class="level-left"><span class="level-item">1</span><span class="level-item">动态代理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#JDK代理"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">JDK代理</span></span></a></li><li><a class="level is-mobile" href="#cglib代理"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">cglib代理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#AOP"><span class="level-left"><span class="level-item">2</span><span class="level-item">AOP</span></span></a></li><li><a class="level is-mobile" href="#Spring中基于XML的AOP"><span class="level-left"><span class="level-item">3</span><span class="level-item">Spring中基于XML的AOP</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#配置Advice类"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">配置Advice类</span></span></a></li><li><a class="level is-mobile" href="#lt-aop-config-gt"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">&lt;aop:config&gt;</span></span></a></li><li><a class="level is-mobile" href="#lt-aop-aspect-gt"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">&lt;aop:aspect&gt;</span></span></a></li><li><a class="level is-mobile" href="#配置Advice类型和切入点"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">配置Advice类型和切入点</span></span></a></li><li><a class="level is-mobile" href="#全通配表达式"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">全通配表达式</span></span></a></li><li><a class="level is-mobile" href="#lt-aop-pointcut-gt"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">&lt;aop:pointcut&gt;</span></span></a></li><li><a class="level is-mobile" href="#Around-Advice切入"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">Around Advice切入</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Spring中基于注解的AOP"><span class="level-left"><span class="level-item">4</span><span class="level-item">Spring中基于注解的AOP</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#lt-aop-aspectj-autoproxy-gt"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">&lt;aop:aspectj-autoproxy&gt;</span></span></a></li><li><a class="level is-mobile" href="#EnableAspectJAutoProxy"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">@EnableAspectJAutoProxy</span></span></a></li><li><a class="level is-mobile" href="#Aspect"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">@Aspect</span></span></a></li><li><a class="level is-mobile" href="#Pointcut"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">@Pointcut</span></span></a></li><li><a class="level is-mobile" href="#Before-After-AfterReturing-AfterThrowing和-Around"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">@Before, @After, @AfterReturing, @AfterThrowing和@Around</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.jpg" alt="Core Dump" height="28"></a><p class="is-size-7"><span>&copy; 2023 s.x.</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xnsi"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>